// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"
	fs "io/fs"

	mock "github.com/stretchr/testify/mock"

	models "github.com/stashapp/stash/pkg/models"
)

// FileReaderWriter is an autogenerated mock type for the FileReaderWriter type
type FileReaderWriter struct {
	mock.Mock
}

// CountAllInPaths provides a mock function with given fields: ctx, p
func (_m *FileReaderWriter) CountAllInPaths(ctx context.Context, p []string) (int, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for CountAllInPaths")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int); ok {
		r0 = rf(ctx, p)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountByFolderID provides a mock function with given fields: ctx, folderID
func (_m *FileReaderWriter) CountByFolderID(ctx context.Context, folderID models.FolderID) (int, error) {
	ret := _m.Called(ctx, folderID)

	if len(ret) == 0 {
		panic("no return value specified for CountByFolderID")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FolderID) (int, error)); ok {
		return rf(ctx, folderID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.FolderID) int); ok {
		r0 = rf(ctx, folderID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.FolderID) error); ok {
		r1 = rf(ctx, folderID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, f
func (_m *FileReaderWriter) Create(ctx context.Context, f models.File) error {
	ret := _m.Called(ctx, f)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.File) error); ok {
		r0 = rf(ctx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Destroy provides a mock function with given fields: ctx, id
func (_m *FileReaderWriter) Destroy(ctx context.Context, id models.FileID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Destroy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DestroyFingerprints provides a mock function with given fields: ctx, fileID, types
func (_m *FileReaderWriter) DestroyFingerprints(ctx context.Context, fileID models.FileID, types []string) error {
	ret := _m.Called(ctx, fileID, types)

	if len(ret) == 0 {
		panic("no return value specified for DestroyFingerprints")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []string) error); ok {
		r0 = rf(ctx, fileID, types)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Find provides a mock function with given fields: ctx, id
func (_m *FileReaderWriter) Find(ctx context.Context, id ...models.FileID) ([]models.File, error) {
	_va := make([]interface{}, len(id))
	for _i := range id {
		_va[_i] = id[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...models.FileID) ([]models.File, error)); ok {
		return rf(ctx, id...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...models.FileID) []models.File); ok {
		r0 = rf(ctx, id...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...models.FileID) error); ok {
		r1 = rf(ctx, id...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAllByPath provides a mock function with given fields: ctx, path
func (_m *FileReaderWriter) FindAllByPath(ctx context.Context, path string) ([]models.File, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for FindAllByPath")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]models.File, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []models.File); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAllInPaths provides a mock function with given fields: ctx, p, limit, offset
func (_m *FileReaderWriter) FindAllInPaths(ctx context.Context, p []string, limit int, offset int) ([]models.File, error) {
	ret := _m.Called(ctx, p, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for FindAllInPaths")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, int, int) ([]models.File, error)); ok {
		return rf(ctx, p, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, int, int) []models.File); ok {
		r0 = rf(ctx, p, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, int, int) error); ok {
		r1 = rf(ctx, p, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByFileInfo provides a mock function with given fields: ctx, info, size
func (_m *FileReaderWriter) FindByFileInfo(ctx context.Context, info fs.FileInfo, size int64) ([]models.File, error) {
	ret := _m.Called(ctx, info, size)

	if len(ret) == 0 {
		panic("no return value specified for FindByFileInfo")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fs.FileInfo, int64) ([]models.File, error)); ok {
		return rf(ctx, info, size)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fs.FileInfo, int64) []models.File); ok {
		r0 = rf(ctx, info, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fs.FileInfo, int64) error); ok {
		r1 = rf(ctx, info, size)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByFingerprint provides a mock function with given fields: ctx, fp
func (_m *FileReaderWriter) FindByFingerprint(ctx context.Context, fp models.Fingerprint) ([]models.File, error) {
	ret := _m.Called(ctx, fp)

	if len(ret) == 0 {
		panic("no return value specified for FindByFingerprint")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.Fingerprint) ([]models.File, error)); ok {
		return rf(ctx, fp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.Fingerprint) []models.File); ok {
		r0 = rf(ctx, fp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.Fingerprint) error); ok {
		r1 = rf(ctx, fp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByPath provides a mock function with given fields: ctx, path
func (_m *FileReaderWriter) FindByPath(ctx context.Context, path string) (models.File, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for FindByPath")
	}

	var r0 models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (models.File, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) models.File); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByZipFileID provides a mock function with given fields: ctx, zipFileID
func (_m *FileReaderWriter) FindByZipFileID(ctx context.Context, zipFileID models.FileID) ([]models.File, error) {
	ret := _m.Called(ctx, zipFileID)

	if len(ret) == 0 {
		panic("no return value specified for FindByZipFileID")
	}

	var r0 []models.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) ([]models.File, error)); ok {
		return rf(ctx, zipFileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) []models.File); ok {
		r0 = rf(ctx, zipFileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, zipFileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCaptions provides a mock function with given fields: ctx, fileID
func (_m *FileReaderWriter) GetCaptions(ctx context.Context, fileID models.FileID) ([]*models.VideoCaption, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetCaptions")
	}

	var r0 []*models.VideoCaption
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) ([]*models.VideoCaption, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) []*models.VideoCaption); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.VideoCaption)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsPrimary provides a mock function with given fields: ctx, fileID
func (_m *FileReaderWriter) IsPrimary(ctx context.Context, fileID models.FileID) (bool, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for IsPrimary")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) (bool, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) bool); ok {
		r0 = rf(ctx, fileID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFingerprints provides a mock function with given fields: ctx, fileID, fingerprints
func (_m *FileReaderWriter) ModifyFingerprints(ctx context.Context, fileID models.FileID, fingerprints []models.Fingerprint) error {
	ret := _m.Called(ctx, fileID, fingerprints)

	if len(ret) == 0 {
		panic("no return value specified for ModifyFingerprints")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []models.Fingerprint) error); ok {
		r0 = rf(ctx, fileID, fingerprints)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query provides a mock function with given fields: ctx, options
func (_m *FileReaderWriter) Query(ctx context.Context, options models.FileQueryOptions) (*models.FileQueryResult, error) {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *models.FileQueryResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileQueryOptions) (*models.FileQueryResult, error)); ok {
		return rf(ctx, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.FileQueryOptions) *models.FileQueryResult); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.FileQueryResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.FileQueryOptions) error); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, f
func (_m *FileReaderWriter) Update(ctx context.Context, f models.File) error {
	ret := _m.Called(ctx, f)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.File) error); ok {
		r0 = rf(ctx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCaptions provides a mock function with given fields: ctx, fileID, captions
func (_m *FileReaderWriter) UpdateCaptions(ctx context.Context, fileID models.FileID, captions []*models.VideoCaption) error {
	ret := _m.Called(ctx, fileID, captions)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCaptions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []*models.VideoCaption) error); ok {
		r0 = rf(ctx, fileID, captions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewFileReaderWriter creates a new instance of FileReaderWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileReaderWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileReaderWriter {
	mock := &FileReaderWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
