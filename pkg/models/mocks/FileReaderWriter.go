// Code generated by mockery v2.10.0. DO NOT EDIT.

package mocks

import (
	context "context"
	fs "io/fs"

	mock "github.com/stretchr/testify/mock"

	models "github.com/stashapp/stash/pkg/models"
)

// FileReaderWriter is an autogenerated mock type for the FileReaderWriter type
type FileReaderWriter struct {
	mock.Mock
}

// CountAllInPaths provides a mock function with given fields: ctx, p
func (_m *FileReaderWriter) CountAllInPaths(ctx context.Context, p []string) (int, error) {
	ret := _m.Called(ctx, p)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, []string) int); ok {
		r0 = rf(ctx, p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountByFolderID provides a mock function with given fields: ctx, folderID
func (_m *FileReaderWriter) CountByFolderID(ctx context.Context, folderID models.FolderID) (int, error) {
	ret := _m.Called(ctx, folderID)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, models.FolderID) int); ok {
		r0 = rf(ctx, folderID)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.FolderID) error); ok {
		r1 = rf(ctx, folderID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, f
func (_m *FileReaderWriter) Create(ctx context.Context, f models.File) error {
	ret := _m.Called(ctx, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.File) error); ok {
		r0 = rf(ctx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Destroy provides a mock function with given fields: ctx, id
func (_m *FileReaderWriter) Destroy(ctx context.Context, id models.FileID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DestroyFingerprints provides a mock function with given fields: ctx, fileID, types
func (_m *FileReaderWriter) DestroyFingerprints(ctx context.Context, fileID models.FileID, types []string) error {
	ret := _m.Called(ctx, fileID, types)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []string) error); ok {
		r0 = rf(ctx, fileID, types)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Find provides a mock function with given fields: ctx, id
func (_m *FileReaderWriter) Find(ctx context.Context, id ...models.FileID) ([]models.File, error) {
	_va := make([]interface{}, len(id))
	for _i := range id {
		_va[_i] = id[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, ...models.FileID) []models.File); ok {
		r0 = rf(ctx, id...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...models.FileID) error); ok {
		r1 = rf(ctx, id...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAllByPath provides a mock function with given fields: ctx, path, caseSensitive
func (_m *FileReaderWriter) FindAllByPath(ctx context.Context, path string, caseSensitive bool) ([]models.File, error) {
	ret := _m.Called(ctx, path, caseSensitive)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) []models.File); ok {
		r0 = rf(ctx, path, caseSensitive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, path, caseSensitive)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAllInPaths provides a mock function with given fields: ctx, p, limit, offset
func (_m *FileReaderWriter) FindAllInPaths(ctx context.Context, p []string, limit int, offset int) ([]models.File, error) {
	ret := _m.Called(ctx, p, limit, offset)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, []string, int, int) []models.File); ok {
		r0 = rf(ctx, p, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []string, int, int) error); ok {
		r1 = rf(ctx, p, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByFileInfo provides a mock function with given fields: ctx, info, size
func (_m *FileReaderWriter) FindByFileInfo(ctx context.Context, info fs.FileInfo, size int64) ([]models.File, error) {
	ret := _m.Called(ctx, info, size)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, fs.FileInfo, int64) []models.File); ok {
		r0 = rf(ctx, info, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, fs.FileInfo, int64) error); ok {
		r1 = rf(ctx, info, size)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByFingerprint provides a mock function with given fields: ctx, fp
func (_m *FileReaderWriter) FindByFingerprint(ctx context.Context, fp models.Fingerprint) ([]models.File, error) {
	ret := _m.Called(ctx, fp)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, models.Fingerprint) []models.File); ok {
		r0 = rf(ctx, fp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.Fingerprint) error); ok {
		r1 = rf(ctx, fp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByPath provides a mock function with given fields: ctx, path, caseSensitive
func (_m *FileReaderWriter) FindByPath(ctx context.Context, path string, caseSensitive bool) (models.File, error) {
	ret := _m.Called(ctx, path, caseSensitive)

	var r0 models.File
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) models.File); ok {
		r0 = rf(ctx, path, caseSensitive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, path, caseSensitive)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByZipFileID provides a mock function with given fields: ctx, zipFileID
func (_m *FileReaderWriter) FindByZipFileID(ctx context.Context, zipFileID models.FileID) ([]models.File, error) {
	ret := _m.Called(ctx, zipFileID)

	var r0 []models.File
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) []models.File); ok {
		r0 = rf(ctx, zipFileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.File)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, zipFileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCaptions provides a mock function with given fields: ctx, fileID
func (_m *FileReaderWriter) GetCaptions(ctx context.Context, fileID models.FileID) ([]*models.VideoCaption, error) {
	ret := _m.Called(ctx, fileID)

	var r0 []*models.VideoCaption
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) []*models.VideoCaption); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.VideoCaption)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsPrimary provides a mock function with given fields: ctx, fileID
func (_m *FileReaderWriter) IsPrimary(ctx context.Context, fileID models.FileID) (bool, error) {
	ret := _m.Called(ctx, fileID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID) bool); ok {
		r0 = rf(ctx, fileID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.FileID) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFingerprints provides a mock function with given fields: ctx, fileID, fingerprints
func (_m *FileReaderWriter) ModifyFingerprints(ctx context.Context, fileID models.FileID, fingerprints []models.Fingerprint) error {
	ret := _m.Called(ctx, fileID, fingerprints)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []models.Fingerprint) error); ok {
		r0 = rf(ctx, fileID, fingerprints)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query provides a mock function with given fields: ctx, options
func (_m *FileReaderWriter) Query(ctx context.Context, options models.FileQueryOptions) (*models.FileQueryResult, error) {
	ret := _m.Called(ctx, options)

	var r0 *models.FileQueryResult
	if rf, ok := ret.Get(0).(func(context.Context, models.FileQueryOptions) *models.FileQueryResult); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.FileQueryResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.FileQueryOptions) error); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, f
func (_m *FileReaderWriter) Update(ctx context.Context, f models.File) error {
	ret := _m.Called(ctx, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.File) error); ok {
		r0 = rf(ctx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCaptions provides a mock function with given fields: ctx, fileID, captions
func (_m *FileReaderWriter) UpdateCaptions(ctx context.Context, fileID models.FileID, captions []*models.VideoCaption) error {
	ret := _m.Called(ctx, fileID, captions)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FileID, []*models.VideoCaption) error); ok {
		r0 = rf(ctx, fileID, captions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
