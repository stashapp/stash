// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type EditDetails interface {
	IsEditDetails()
}

type EditTarget interface {
	IsEditTarget()
}

type ApplyEditInput struct {
	ID string `json:"id"`
}

type BodyModification struct {
	Location    string  `json:"location"`
	Description *string `json:"description"`
}

type BodyModificationCriterionInput struct {
	Location    *string           `json:"location"`
	Description *string           `json:"description"`
	Modifier    CriterionModifier `json:"modifier"`
}

type BodyModificationInput struct {
	Location    string  `json:"location"`
	Description *string `json:"description"`
}

type BreastTypeCriterionInput struct {
	Value    *BreastTypeEnum   `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type CancelEditInput struct {
	ID string `json:"id"`
}

type DateCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Edit struct {
	ID   string `json:"id"`
	User *User  `json:"user"`
	// Object being edited - null if creating a new object
	Target     EditTarget     `json:"target"`
	TargetType TargetTypeEnum `json:"target_type"`
	// Objects to merge with the target. Only applicable to merges
	MergeSources []EditTarget   `json:"merge_sources"`
	Operation    OperationEnum  `json:"operation"`
	Details      EditDetails    `json:"details"`
	Comments     []*EditComment `json:"comments"`
	Votes        []*VoteComment `json:"votes"`
	//  = Accepted - Rejected
	VoteCount int            `json:"vote_count"`
	Status    VoteStatusEnum `json:"status"`
	Applied   bool           `json:"applied"`
	Created   time.Time      `json:"created"`
}

type EditComment struct {
	User    *User     `json:"user"`
	Date    time.Time `json:"date"`
	Comment string    `json:"comment"`
}

type EditCommentInput struct {
	ID      string `json:"id"`
	Comment string `json:"comment"`
}

type EditFilterType struct {
	// Filter by user id
	UserID *string `json:"user_id"`
	// Filter by status
	Status *VoteStatusEnum `json:"status"`
	// Filter by operation
	Operation *OperationEnum `json:"operation"`
	// Filter by vote count
	VoteCount *IntCriterionInput `json:"vote_count"`
	// Filter by applied status
	Applied *bool `json:"applied"`
	// Filter by target type
	TargetType *TargetTypeEnum `json:"target_type"`
	// Filter by target id
	TargetID *string `json:"target_id"`
}

type EditInput struct {
	// Not required for create type
	ID        *string       `json:"id"`
	Operation OperationEnum `json:"operation"`
	// Required for amending an existing edit
	EditID *string `json:"edit_id"`
	// Only required for merge type
	MergeSourceIds []string `json:"merge_source_ids"`
	Comment        *string  `json:"comment"`
}

type EditVoteInput struct {
	ID      string       `json:"id"`
	Comment *string      `json:"comment"`
	Type    VoteTypeEnum `json:"type"`
}

type EthnicityCriterionInput struct {
	Value    *EthnicityEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type EyeColorCriterionInput struct {
	Value    *EyeColorEnum     `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Fingerprint struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type FingerprintInput struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type FingerprintQueryInput struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
}

type FingerprintSubmission struct {
	SceneID     string            `json:"scene_id"`
	Fingerprint *FingerprintInput `json:"fingerprint"`
}

type FuzzyDate struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type FuzzyDateInput struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type HairColorCriterionInput struct {
	Value    *HairColorEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type IDCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Image struct {
	ID     string `json:"id"`
	URL    string `json:"url"`
	Width  *int   `json:"width"`
	Height *int   `json:"height"`
}

type ImageCreateInput struct {
	URL string `json:"url"`
}

type ImageDestroyInput struct {
	ID string `json:"id"`
}

type ImageUpdateInput struct {
	ID  string `json:"id"`
	URL string `json:"url"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Measurements struct {
	CupSize  *string `json:"cup_size"`
	BandSize *int    `json:"band_size"`
	Waist    *int    `json:"waist"`
	Hip      *int    `json:"hip"`
}

type MeasurementsInput struct {
	CupSize  *string `json:"cup_size"`
	BandSize *int    `json:"band_size"`
	Waist    *int    `json:"waist"`
	Hip      *int    `json:"hip"`
}

type MultiIDCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Performer struct {
	ID             string         `json:"id"`
	Name           string         `json:"name"`
	Disambiguation *string        `json:"disambiguation"`
	Aliases        []string       `json:"aliases"`
	Gender         *GenderEnum    `json:"gender"`
	Urls           []*URL         `json:"urls"`
	Birthdate      *FuzzyDate     `json:"birthdate"`
	Age            *int           `json:"age"`
	Ethnicity      *EthnicityEnum `json:"ethnicity"`
	Country        *string        `json:"country"`
	EyeColor       *EyeColorEnum  `json:"eye_color"`
	HairColor      *HairColorEnum `json:"hair_color"`
	// Height in cm
	Height          *int                `json:"height"`
	Measurements    *Measurements       `json:"measurements"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	Images          []*Image            `json:"images"`
	Deleted         bool                `json:"deleted"`
}

func (Performer) IsEditTarget() {}

type PerformerAppearance struct {
	Performer *Performer `json:"performer"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerAppearanceInput struct {
	PerformerID string `json:"performer_id"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerCreateInput struct {
	Name            string                   `json:"name"`
	Disambiguation  *string                  `json:"disambiguation"`
	Aliases         []string                 `json:"aliases"`
	Gender          *GenderEnum              `json:"gender"`
	Urls            []*URLInput              `json:"urls"`
	Birthdate       *FuzzyDateInput          `json:"birthdate"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity"`
	Country         *string                  `json:"country"`
	EyeColor        *EyeColorEnum            `json:"eye_color"`
	HairColor       *HairColorEnum           `json:"hair_color"`
	Height          *int                     `json:"height"`
	Measurements    *MeasurementsInput       `json:"measurements"`
	BreastType      *BreastTypeEnum          `json:"breast_type"`
	CareerStartYear *int                     `json:"career_start_year"`
	CareerEndYear   *int                     `json:"career_end_year"`
	Tattoos         []*BodyModificationInput `json:"tattoos"`
	Piercings       []*BodyModificationInput `json:"piercings"`
	ImageIds        []string                 `json:"image_ids"`
}

type PerformerDestroyInput struct {
	ID string `json:"id"`
}

type PerformerEdit struct {
	Name           *string        `json:"name"`
	Disambiguation *string        `json:"disambiguation"`
	AddedAliases   []string       `json:"added_aliases"`
	RemovedAliases []string       `json:"removed_aliases"`
	Gender         *GenderEnum    `json:"gender"`
	AddedUrls      []*URL         `json:"added_urls"`
	RemovedUrls    []*URL         `json:"removed_urls"`
	Birthdate      *FuzzyDate     `json:"birthdate"`
	Ethnicity      *EthnicityEnum `json:"ethnicity"`
	Country        *string        `json:"country"`
	EyeColor       *EyeColorEnum  `json:"eye_color"`
	HairColor      *HairColorEnum `json:"hair_color"`
	// Height in cm
	Height           *int                `json:"height"`
	Measurements     *Measurements       `json:"measurements"`
	BreastType       *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear  *int                `json:"career_start_year"`
	CareerEndYear    *int                `json:"career_end_year"`
	AddedTattoos     []*BodyModification `json:"added_tattoos"`
	RemovedTattoos   []*BodyModification `json:"removed_tattoos"`
	AddedPiercings   []*BodyModification `json:"added_piercings"`
	RemovedPiercings []*BodyModification `json:"removed_piercings"`
	AddedImages      []*Image            `json:"added_images"`
	RemovedImages    []*Image            `json:"removed_images"`
}

func (PerformerEdit) IsEditDetails() {}

type PerformerEditDetailsInput struct {
	Name            *string                  `json:"name"`
	Disambiguation  *string                  `json:"disambiguation"`
	Aliases         []string                 `json:"aliases"`
	Gender          *GenderEnum              `json:"gender"`
	Urls            []*URLInput              `json:"urls"`
	Birthdate       *FuzzyDateInput          `json:"birthdate"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity"`
	Country         *string                  `json:"country"`
	EyeColor        *EyeColorEnum            `json:"eye_color"`
	HairColor       *HairColorEnum           `json:"hair_color"`
	Height          *int                     `json:"height"`
	Measurements    *MeasurementsInput       `json:"measurements"`
	BreastType      *BreastTypeEnum          `json:"breast_type"`
	CareerStartYear *int                     `json:"career_start_year"`
	CareerEndYear   *int                     `json:"career_end_year"`
	Tattoos         []*BodyModificationInput `json:"tattoos"`
	Piercings       []*BodyModificationInput `json:"piercings"`
	ImageIds        []string                 `json:"image_ids"`
}

type PerformerEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *PerformerEditDetailsInput `json:"details"`
}

type PerformerFilterType struct {
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names"`
	// Searches name only - assumes like query unless quoted
	Name *string `json:"name"`
	// Search aliases only - assumes like query unless quoted
	Alias          *string               `json:"alias"`
	Disambiguation *StringCriterionInput `json:"disambiguation"`
	Gender         *GenderEnum           `json:"gender"`
	// Filter to search urls - assumes like query unless quoted
	URL             *string                         `json:"url"`
	Birthdate       *DateCriterionInput             `json:"birthdate"`
	BirthYear       *IntCriterionInput              `json:"birth_year"`
	Age             *IntCriterionInput              `json:"age"`
	Ethnicity       *EthnicityCriterionInput        `json:"ethnicity"`
	Country         *StringCriterionInput           `json:"country"`
	EyeColor        *EyeColorCriterionInput         `json:"eye_color"`
	HairColor       *HairColorCriterionInput        `json:"hair_color"`
	Height          *IntCriterionInput              `json:"height"`
	CupSize         *StringCriterionInput           `json:"cup_size"`
	BandSize        *IntCriterionInput              `json:"band_size"`
	WaistSize       *IntCriterionInput              `json:"waist_size"`
	HipSize         *IntCriterionInput              `json:"hip_size"`
	BreastType      *BreastTypeCriterionInput       `json:"breast_type"`
	CareerStartYear *IntCriterionInput              `json:"career_start_year"`
	CareerEndYear   *IntCriterionInput              `json:"career_end_year"`
	Tattoos         *BodyModificationCriterionInput `json:"tattoos"`
	Piercings       *BodyModificationCriterionInput `json:"piercings"`
}

type PerformerUpdateInput struct {
	ID              string                   `json:"id"`
	Name            *string                  `json:"name"`
	Disambiguation  *string                  `json:"disambiguation"`
	Aliases         []string                 `json:"aliases"`
	Gender          *GenderEnum              `json:"gender"`
	Urls            []*URLInput              `json:"urls"`
	Birthdate       *FuzzyDateInput          `json:"birthdate"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity"`
	Country         *string                  `json:"country"`
	EyeColor        *EyeColorEnum            `json:"eye_color"`
	HairColor       *HairColorEnum           `json:"hair_color"`
	Height          *int                     `json:"height"`
	Measurements    *MeasurementsInput       `json:"measurements"`
	BreastType      *BreastTypeEnum          `json:"breast_type"`
	CareerStartYear *int                     `json:"career_start_year"`
	CareerEndYear   *int                     `json:"career_end_year"`
	Tattoos         []*BodyModificationInput `json:"tattoos"`
	Piercings       []*BodyModificationInput `json:"piercings"`
	ImageIds        []string                 `json:"image_ids"`
}

type QueryEditsResultType struct {
	Count int     `json:"count"`
	Edits []*Edit `json:"edits"`
}

type QueryPerformersResultType struct {
	Count      int          `json:"count"`
	Performers []*Performer `json:"performers"`
}

type QueryScenesResultType struct {
	Count  int      `json:"count"`
	Scenes []*Scene `json:"scenes"`
}

type QuerySpec struct {
	Page      *int               `json:"page"`
	PerPage   *int               `json:"per_page"`
	Sort      *string            `json:"sort"`
	Direction *SortDirectionEnum `json:"direction"`
}

type QueryStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type QueryTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type QueryUsersResultType struct {
	Count int     `json:"count"`
	Users []*User `json:"users"`
}

type RoleCriterionInput struct {
	Value    []RoleEnum        `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Scene struct {
	ID           string                 `json:"id"`
	Title        *string                `json:"title"`
	Details      *string                `json:"details"`
	Date         *string                `json:"date"`
	Urls         []*URL                 `json:"urls"`
	Studio       *Studio                `json:"studio"`
	Tags         []*Tag                 `json:"tags"`
	Images       []*Image               `json:"images"`
	Performers   []*PerformerAppearance `json:"performers"`
	Fingerprints []*Fingerprint         `json:"fingerprints"`
	Duration     *int                   `json:"duration"`
	Director     *string                `json:"director"`
	Deleted      bool                   `json:"deleted"`
}

func (Scene) IsEditTarget() {}

type SceneCreateInput struct {
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *string                     `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []string                    `json:"tag_ids"`
	ImageIds     []string                    `json:"image_ids"`
	Fingerprints []*FingerprintInput         `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
}

type SceneDestroyInput struct {
	ID string `json:"id"`
}

type SceneEdit struct {
	Title       *string `json:"title"`
	Details     *string `json:"details"`
	AddedUrls   []*URL  `json:"added_urls"`
	RemovedUrls []*URL  `json:"removed_urls"`
	Date        *string `json:"date"`
	StudioID    *string `json:"studio_id"`
	// Added or modified performer appearance entries
	AddedPerformers     []*PerformerAppearance `json:"added_performers"`
	RemovedPerformers   []*PerformerAppearance `json:"removed_performers"`
	AddedTags           []*Tag                 `json:"added_tags"`
	RemovedTags         []*Tag                 `json:"removed_tags"`
	AddedImages         []*Image               `json:"added_images"`
	RemovedImages       []*Image               `json:"removed_images"`
	AddedFingerprints   []*Fingerprint         `json:"added_fingerprints"`
	RemovedFingerprints []*Fingerprint         `json:"removed_fingerprints"`
	Duration            *int                   `json:"duration"`
	Director            *string                `json:"director"`
}

func (SceneEdit) IsEditDetails() {}

type SceneEditDetailsInput struct {
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *string                     `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []string                    `json:"tag_ids"`
	ImageIds     []string                    `json:"image_ids"`
	Fingerprints []*FingerprintInput         `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
}

type SceneEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details  *SceneEditDetailsInput `json:"details"`
	Duration *int                   `json:"duration"`
}

type SceneFilterType struct {
	// Filter to search title and details - assumes like query unless quoted
	Text *string `json:"text"`
	// Filter to search title - assumes like query unless quoted
	Title *string `json:"title"`
	// Filter to search urls - assumes like query unless quoted
	URL *string `json:"url"`
	// Filter by date
	Date *DateCriterionInput `json:"date"`
	// Filter to only include scenes with this studio
	Studios *MultiIDCriterionInput `json:"studios"`
	// Filter to only include scenes with these tags
	Tags *MultiIDCriterionInput `json:"tags"`
	// Filter to only include scenes with these performers
	Performers *MultiIDCriterionInput `json:"performers"`
	// Filter to include scenes with performer appearing as alias
	Alias *StringCriterionInput `json:"alias"`
}

type SceneUpdateInput struct {
	ID           string                      `json:"id"`
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *string                     `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []string                    `json:"tag_ids"`
	ImageIds     []string                    `json:"image_ids"`
	Fingerprints []*FingerprintInput         `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Studio struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Urls         []*URL    `json:"urls"`
	Parent       *Studio   `json:"parent"`
	ChildStudios []*Studio `json:"child_studios"`
	Images       []*Image  `json:"images"`
	Deleted      bool      `json:"deleted"`
}

func (Studio) IsEditTarget() {}

type StudioCreateInput struct {
	Name           string      `json:"name"`
	Urls           []*URLInput `json:"urls"`
	ParentID       *string     `json:"parent_id"`
	ChildStudioIds []string    `json:"child_studio_ids"`
	ImageIds       []string    `json:"image_ids"`
}

type StudioDestroyInput struct {
	ID string `json:"id"`
}

type StudioEdit struct {
	Name *string `json:"name"`
	// Added and modified URLs
	AddedUrls           []*URL    `json:"added_urls"`
	RemovedUrls         []*URL    `json:"removed_urls"`
	Parent              *Studio   `json:"parent"`
	AddedChildStudios   []*Studio `json:"added_child_studios"`
	RemovedChildStudios []*Studio `json:"removed_child_studios"`
	AddedImages         []*Image  `json:"added_images"`
	RemovedImages       []*Image  `json:"removed_images"`
}

func (StudioEdit) IsEditDetails() {}

type StudioEditDetailsInput struct {
	Name           *string     `json:"name"`
	Urls           []*URLInput `json:"urls"`
	ParentID       *string     `json:"parent_id"`
	ChildStudioIds []string    `json:"child_studio_ids"`
	ImageIds       []string    `json:"image_ids"`
}

type StudioEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *StudioEditDetailsInput `json:"details"`
}

type StudioFilterType struct {
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search url - assumes like query unless quoted
	URL    *string           `json:"url"`
	Parent *IDCriterionInput `json:"parent"`
}

type StudioUpdateInput struct {
	ID             string      `json:"id"`
	Name           *string     `json:"name"`
	Urls           []*URLInput `json:"urls"`
	ParentID       *string     `json:"parent_id"`
	ChildStudioIds []string    `json:"child_studio_ids"`
	ImageIds       []string    `json:"image_ids"`
}

type Tag struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
	Deleted     bool     `json:"deleted"`
	Edits       []*Edit  `json:"edits"`
}

func (Tag) IsEditTarget() {}

type TagCreateInput struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
}

type TagDestroyInput struct {
	ID string `json:"id"`
}

type TagEdit struct {
	Name           *string  `json:"name"`
	Description    *string  `json:"description"`
	AddedAliases   []string `json:"added_aliases"`
	RemovedAliases []string `json:"removed_aliases"`
}

func (TagEdit) IsEditDetails() {}

type TagEditDetailsInput struct {
	Name        *string  `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
}

type TagEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *TagEditDetailsInput `json:"details"`
}

type TagFilterType struct {
	// Filter to search name, aliases and description - assumes like query unless quoted
	Text *string `json:"text"`
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names"`
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
}

type TagUpdateInput struct {
	ID          string   `json:"id"`
	Name        *string  `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
}

type URL struct {
	URL  string `json:"url"`
	Type string `json:"type"`
}

type URLInput struct {
	URL  string `json:"url"`
	Type string `json:"type"`
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// Should not be visible to other users
	Roles []RoleEnum `json:"roles"`
	// Should not be visible to other users
	Email *string `json:"email"`
	// Should not be visible to other users
	APIKey            *string `json:"api_key"`
	SuccessfulEdits   int     `json:"successful_edits"`
	UnsuccessfulEdits int     `json:"unsuccessful_edits"`
	SuccessfulVotes   int     `json:"successful_votes"`
	// Votes on unsuccessful edits
	UnsuccessfulVotes int `json:"unsuccessful_votes"`
	// Calls to the API from this user over a configurable time period
	APICalls int `json:"api_calls"`
}

type UserChangePasswordInput struct {
	// Password in plain text
	ExistingPassword string `json:"existing_password"`
	NewPassword      string `json:"new_password"`
}

type UserCreateInput struct {
	Name string `json:"name"`
	// Password in plain text
	Password string     `json:"password"`
	Roles    []RoleEnum `json:"roles"`
	Email    string     `json:"email"`
}

type UserDestroyInput struct {
	ID string `json:"id"`
}

type UserFilterType struct {
	// Filter to search user name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search email - assumes like query unless quoted
	Email *string `json:"email"`
	// Filter by roles
	Roles *RoleCriterionInput `json:"roles"`
	// Filter by api key
	APIKey *string `json:"apiKey"`
	// Filter by successful edits
	SuccessfulEdits *IntCriterionInput `json:"successful_edits"`
	// Filter by unsuccessful edits
	UnsuccessfulEdits *IntCriterionInput `json:"unsuccessful_edits"`
	// Filter by votes on successful edits
	SuccessfulVotes *IntCriterionInput `json:"successful_votes"`
	// Filter by votes on unsuccessful edits
	UnsuccessfulVotes *IntCriterionInput `json:"unsuccessful_votes"`
	// Filter by number of API calls
	APICalls *IntCriterionInput `json:"api_calls"`
}

type UserUpdateInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name"`
	// Password in plain text
	Password *string    `json:"password"`
	Roles    []RoleEnum `json:"roles"`
	Email    *string    `json:"email"`
}

type Version struct {
	Hash      string `json:"hash"`
	BuildTime string `json:"build_time"`
	Version   string `json:"version"`
}

type VoteComment struct {
	User    *User         `json:"user"`
	Date    *string       `json:"date"`
	Comment *string       `json:"comment"`
	Type    *VoteTypeEnum `json:"type"`
}

type BreastTypeEnum string

const (
	BreastTypeEnumNatural BreastTypeEnum = "NATURAL"
	BreastTypeEnumFake    BreastTypeEnum = "FAKE"
	BreastTypeEnumNa      BreastTypeEnum = "NA"
)

var AllBreastTypeEnum = []BreastTypeEnum{
	BreastTypeEnumNatural,
	BreastTypeEnumFake,
	BreastTypeEnumNa,
}

func (e BreastTypeEnum) IsValid() bool {
	switch e {
	case BreastTypeEnumNatural, BreastTypeEnumFake, BreastTypeEnumNa:
		return true
	}
	return false
}

func (e BreastTypeEnum) String() string {
	return string(e)
}

func (e *BreastTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BreastTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BreastTypeEnum", str)
	}
	return nil
}

func (e BreastTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DateAccuracyEnum string

const (
	DateAccuracyEnumYear  DateAccuracyEnum = "YEAR"
	DateAccuracyEnumMonth DateAccuracyEnum = "MONTH"
	DateAccuracyEnumDay   DateAccuracyEnum = "DAY"
)

var AllDateAccuracyEnum = []DateAccuracyEnum{
	DateAccuracyEnumYear,
	DateAccuracyEnumMonth,
	DateAccuracyEnumDay,
}

func (e DateAccuracyEnum) IsValid() bool {
	switch e {
	case DateAccuracyEnumYear, DateAccuracyEnumMonth, DateAccuracyEnumDay:
		return true
	}
	return false
}

func (e DateAccuracyEnum) String() string {
	return string(e)
}

func (e *DateAccuracyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateAccuracyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateAccuracyEnum", str)
	}
	return nil
}

func (e DateAccuracyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityEnum string

const (
	EthnicityEnumCaucasian     EthnicityEnum = "CAUCASIAN"
	EthnicityEnumBlack         EthnicityEnum = "BLACK"
	EthnicityEnumAsian         EthnicityEnum = "ASIAN"
	EthnicityEnumIndian        EthnicityEnum = "INDIAN"
	EthnicityEnumLatin         EthnicityEnum = "LATIN"
	EthnicityEnumMiddleEastern EthnicityEnum = "MIDDLE_EASTERN"
	EthnicityEnumMixed         EthnicityEnum = "MIXED"
	EthnicityEnumOther         EthnicityEnum = "OTHER"
)

var AllEthnicityEnum = []EthnicityEnum{
	EthnicityEnumCaucasian,
	EthnicityEnumBlack,
	EthnicityEnumAsian,
	EthnicityEnumIndian,
	EthnicityEnumLatin,
	EthnicityEnumMiddleEastern,
	EthnicityEnumMixed,
	EthnicityEnumOther,
}

func (e EthnicityEnum) IsValid() bool {
	switch e {
	case EthnicityEnumCaucasian, EthnicityEnumBlack, EthnicityEnumAsian, EthnicityEnumIndian, EthnicityEnumLatin, EthnicityEnumMiddleEastern, EthnicityEnumMixed, EthnicityEnumOther:
		return true
	}
	return false
}

func (e EthnicityEnum) String() string {
	return string(e)
}

func (e *EthnicityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityEnum", str)
	}
	return nil
}

func (e EthnicityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EyeColorEnum string

const (
	EyeColorEnumBlue  EyeColorEnum = "BLUE"
	EyeColorEnumBrown EyeColorEnum = "BROWN"
	EyeColorEnumGrey  EyeColorEnum = "GREY"
	EyeColorEnumGreen EyeColorEnum = "GREEN"
	EyeColorEnumHazel EyeColorEnum = "HAZEL"
	EyeColorEnumRed   EyeColorEnum = "RED"
)

var AllEyeColorEnum = []EyeColorEnum{
	EyeColorEnumBlue,
	EyeColorEnumBrown,
	EyeColorEnumGrey,
	EyeColorEnumGreen,
	EyeColorEnumHazel,
	EyeColorEnumRed,
}

func (e EyeColorEnum) IsValid() bool {
	switch e {
	case EyeColorEnumBlue, EyeColorEnumBrown, EyeColorEnumGrey, EyeColorEnumGreen, EyeColorEnumHazel, EyeColorEnumRed:
		return true
	}
	return false
}

func (e EyeColorEnum) String() string {
	return string(e)
}

func (e *EyeColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EyeColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EyeColorEnum", str)
	}
	return nil
}

func (e EyeColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FingerprintAlgorithm string

const (
	FingerprintAlgorithmMd5    FingerprintAlgorithm = "MD5"
	FingerprintAlgorithmOshash FingerprintAlgorithm = "OSHASH"
)

var AllFingerprintAlgorithm = []FingerprintAlgorithm{
	FingerprintAlgorithmMd5,
	FingerprintAlgorithmOshash,
}

func (e FingerprintAlgorithm) IsValid() bool {
	switch e {
	case FingerprintAlgorithmMd5, FingerprintAlgorithmOshash:
		return true
	}
	return false
}

func (e FingerprintAlgorithm) String() string {
	return string(e)
}

func (e *FingerprintAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FingerprintAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FingerprintAlgorithm", str)
	}
	return nil
}

func (e FingerprintAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HairColorEnum string

const (
	HairColorEnumBlonde   HairColorEnum = "BLONDE"
	HairColorEnumBrunette HairColorEnum = "BRUNETTE"
	HairColorEnumBlack    HairColorEnum = "BLACK"
	HairColorEnumRed      HairColorEnum = "RED"
	HairColorEnumAuburn   HairColorEnum = "AUBURN"
	HairColorEnumGrey     HairColorEnum = "GREY"
	HairColorEnumBald     HairColorEnum = "BALD"
	HairColorEnumVarious  HairColorEnum = "VARIOUS"
	HairColorEnumOther    HairColorEnum = "OTHER"
)

var AllHairColorEnum = []HairColorEnum{
	HairColorEnumBlonde,
	HairColorEnumBrunette,
	HairColorEnumBlack,
	HairColorEnumRed,
	HairColorEnumAuburn,
	HairColorEnumGrey,
	HairColorEnumBald,
	HairColorEnumVarious,
	HairColorEnumOther,
}

func (e HairColorEnum) IsValid() bool {
	switch e {
	case HairColorEnumBlonde, HairColorEnumBrunette, HairColorEnumBlack, HairColorEnumRed, HairColorEnumAuburn, HairColorEnumGrey, HairColorEnumBald, HairColorEnumVarious, HairColorEnumOther:
		return true
	}
	return false
}

func (e HairColorEnum) String() string {
	return string(e)
}

func (e *HairColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HairColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HairColorEnum", str)
	}
	return nil
}

func (e HairColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationEnum string

const (
	OperationEnumCreate  OperationEnum = "CREATE"
	OperationEnumModify  OperationEnum = "MODIFY"
	OperationEnumDestroy OperationEnum = "DESTROY"
	OperationEnumMerge   OperationEnum = "MERGE"
)

var AllOperationEnum = []OperationEnum{
	OperationEnumCreate,
	OperationEnumModify,
	OperationEnumDestroy,
	OperationEnumMerge,
}

func (e OperationEnum) IsValid() bool {
	switch e {
	case OperationEnumCreate, OperationEnumModify, OperationEnumDestroy, OperationEnumMerge:
		return true
	}
	return false
}

func (e OperationEnum) String() string {
	return string(e)
}

func (e *OperationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationEnum", str)
	}
	return nil
}

func (e OperationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleEnum string

const (
	RoleEnumRead   RoleEnum = "READ"
	RoleEnumVote   RoleEnum = "VOTE"
	RoleEnumEdit   RoleEnum = "EDIT"
	RoleEnumModify RoleEnum = "MODIFY"
	RoleEnumAdmin  RoleEnum = "ADMIN"
)

var AllRoleEnum = []RoleEnum{
	RoleEnumRead,
	RoleEnumVote,
	RoleEnumEdit,
	RoleEnumModify,
	RoleEnumAdmin,
}

func (e RoleEnum) IsValid() bool {
	switch e {
	case RoleEnumRead, RoleEnumVote, RoleEnumEdit, RoleEnumModify, RoleEnumAdmin:
		return true
	}
	return false
}

func (e RoleEnum) String() string {
	return string(e)
}

func (e *RoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleEnum", str)
	}
	return nil
}

func (e RoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetTypeEnum string

const (
	TargetTypeEnumScene     TargetTypeEnum = "SCENE"
	TargetTypeEnumStudio    TargetTypeEnum = "STUDIO"
	TargetTypeEnumPerformer TargetTypeEnum = "PERFORMER"
	TargetTypeEnumTag       TargetTypeEnum = "TAG"
)

var AllTargetTypeEnum = []TargetTypeEnum{
	TargetTypeEnumScene,
	TargetTypeEnumStudio,
	TargetTypeEnumPerformer,
	TargetTypeEnumTag,
}

func (e TargetTypeEnum) IsValid() bool {
	switch e {
	case TargetTypeEnumScene, TargetTypeEnumStudio, TargetTypeEnumPerformer, TargetTypeEnumTag:
		return true
	}
	return false
}

func (e TargetTypeEnum) String() string {
	return string(e)
}

func (e *TargetTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetTypeEnum", str)
	}
	return nil
}

func (e TargetTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteStatusEnum string

const (
	VoteStatusEnumAccepted          VoteStatusEnum = "ACCEPTED"
	VoteStatusEnumRejected          VoteStatusEnum = "REJECTED"
	VoteStatusEnumPending           VoteStatusEnum = "PENDING"
	VoteStatusEnumImmediateAccepted VoteStatusEnum = "IMMEDIATE_ACCEPTED"
	VoteStatusEnumImmediateRejected VoteStatusEnum = "IMMEDIATE_REJECTED"
)

var AllVoteStatusEnum = []VoteStatusEnum{
	VoteStatusEnumAccepted,
	VoteStatusEnumRejected,
	VoteStatusEnumPending,
	VoteStatusEnumImmediateAccepted,
	VoteStatusEnumImmediateRejected,
}

func (e VoteStatusEnum) IsValid() bool {
	switch e {
	case VoteStatusEnumAccepted, VoteStatusEnumRejected, VoteStatusEnumPending, VoteStatusEnumImmediateAccepted, VoteStatusEnumImmediateRejected:
		return true
	}
	return false
}

func (e VoteStatusEnum) String() string {
	return string(e)
}

func (e *VoteStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteStatusEnum", str)
	}
	return nil
}

func (e VoteStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteTypeEnum string

const (
	VoteTypeEnumComment VoteTypeEnum = "COMMENT"
	VoteTypeEnumAccept  VoteTypeEnum = "ACCEPT"
	VoteTypeEnumReject  VoteTypeEnum = "REJECT"
	// Immediately accepts the edit - bypassing the vote
	VoteTypeEnumImmediateAccept VoteTypeEnum = "IMMEDIATE_ACCEPT"
	// Immediately rejects the edit - bypassing the vote
	VoteTypeEnumImmediateReject VoteTypeEnum = "IMMEDIATE_REJECT"
)

var AllVoteTypeEnum = []VoteTypeEnum{
	VoteTypeEnumComment,
	VoteTypeEnumAccept,
	VoteTypeEnumReject,
	VoteTypeEnumImmediateAccept,
	VoteTypeEnumImmediateReject,
}

func (e VoteTypeEnum) IsValid() bool {
	switch e {
	case VoteTypeEnumComment, VoteTypeEnumAccept, VoteTypeEnumReject, VoteTypeEnumImmediateAccept, VoteTypeEnumImmediateReject:
		return true
	}
	return false
}

func (e VoteTypeEnum) String() string {
	return string(e)
}

func (e *VoteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteTypeEnum", str)
	}
	return nil
}

func (e VoteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
