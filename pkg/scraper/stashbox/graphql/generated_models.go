// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

type DraftData interface {
	IsDraftData()
}

type EditDetails interface {
	IsEditDetails()
}

type EditTarget interface {
	IsEditTarget()
}

type SceneDraftPerformer interface {
	IsSceneDraftPerformer()
}

type SceneDraftStudio interface {
	IsSceneDraftStudio()
}

type SceneDraftTag interface {
	IsSceneDraftTag()
}

type ActivateNewUserInput struct {
	Name          string `json:"name"`
	Email         string `json:"email"`
	ActivationKey string `json:"activation_key"`
	Password      string `json:"password"`
}

type ApplyEditInput struct {
	ID string `json:"id"`
}

type BodyModification struct {
	Location    string  `json:"location"`
	Description *string `json:"description,omitempty"`
}

type BodyModificationCriterionInput struct {
	Location    *string           `json:"location,omitempty"`
	Description *string           `json:"description,omitempty"`
	Modifier    CriterionModifier `json:"modifier"`
}

type BodyModificationInput struct {
	Location    string  `json:"location"`
	Description *string `json:"description,omitempty"`
}

type BreastTypeCriterionInput struct {
	Value    *BreastTypeEnum   `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type CancelEditInput struct {
	ID string `json:"id"`
}

type DateCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Draft struct {
	ID      string    `json:"id"`
	Created time.Time `json:"created"`
	Expires time.Time `json:"expires"`
	Data    DraftData `json:"data"`
}

type DraftEntity struct {
	Name string  `json:"name"`
	ID   *string `json:"id,omitempty"`
}

func (DraftEntity) IsSceneDraftPerformer() {}

func (DraftEntity) IsSceneDraftStudio() {}

func (DraftEntity) IsSceneDraftTag() {}

type DraftEntityInput struct {
	Name string  `json:"name"`
	ID   *string `json:"id,omitempty"`
}

type DraftFingerprint struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type DraftSubmissionStatus struct {
	ID *string `json:"id,omitempty"`
}

type Edit struct {
	ID   string `json:"id"`
	User *User  `json:"user,omitempty"`
	// Object being edited - null if creating a new object
	Target     EditTarget     `json:"target,omitempty"`
	TargetType TargetTypeEnum `json:"target_type"`
	// Objects to merge with the target. Only applicable to merges
	MergeSources []EditTarget  `json:"merge_sources"`
	Operation    OperationEnum `json:"operation"`
	Bot          bool          `json:"bot"`
	Details      EditDetails   `json:"details,omitempty"`
	// Previous state of fields being modified - null if operation is create or delete.
	OldDetails EditDetails `json:"old_details,omitempty"`
	// Entity specific options
	Options  *PerformerEditOptions `json:"options,omitempty"`
	Comments []*EditComment        `json:"comments"`
	Votes    []*EditVote           `json:"votes"`
	//  = Accepted - Rejected
	VoteCount int `json:"vote_count"`
	// Is the edit considered destructive.
	Destructive bool           `json:"destructive"`
	Status      VoteStatusEnum `json:"status"`
	Applied     bool           `json:"applied"`
	Created     time.Time      `json:"created"`
	Updated     *time.Time     `json:"updated,omitempty"`
	Closed      *time.Time     `json:"closed,omitempty"`
	Expires     *time.Time     `json:"expires,omitempty"`
}

type EditComment struct {
	ID      string    `json:"id"`
	User    *User     `json:"user,omitempty"`
	Date    time.Time `json:"date"`
	Comment string    `json:"comment"`
}

type EditCommentInput struct {
	ID      string `json:"id"`
	Comment string `json:"comment"`
}

type EditInput struct {
	// Not required for create type
	ID        *string       `json:"id,omitempty"`
	Operation OperationEnum `json:"operation"`
	// Only required for merge type
	MergeSourceIds []string `json:"merge_source_ids,omitempty"`
	Comment        *string  `json:"comment,omitempty"`
	// Edit submitted by an automated script. Requires bot permission
	Bot *bool `json:"bot,omitempty"`
}

type EditQueryInput struct {
	// Filter by user id
	UserID *string `json:"user_id,omitempty"`
	// Filter by status
	Status *VoteStatusEnum `json:"status,omitempty"`
	// Filter by operation
	Operation *OperationEnum `json:"operation,omitempty"`
	// Filter by vote count
	VoteCount *IntCriterionInput `json:"vote_count,omitempty"`
	// Filter by applied status
	Applied *bool `json:"applied,omitempty"`
	// Filter by target type
	TargetType *TargetTypeEnum `json:"target_type,omitempty"`
	// Filter by target id
	TargetID *string `json:"target_id,omitempty"`
	// Filter by favorite status
	IsFavorite *bool `json:"is_favorite,omitempty"`
	// Filter by user voted status
	Voted *UserVotedFilterEnum `json:"voted,omitempty"`
	// Filter to bot edits only
	IsBot *bool `json:"is_bot,omitempty"`
	// Filter out user's own edits
	IncludeUserSubmitted *bool             `json:"include_user_submitted,omitempty"`
	Page                 int               `json:"page"`
	PerPage              int               `json:"per_page"`
	Direction            SortDirectionEnum `json:"direction"`
	Sort                 EditSortEnum      `json:"sort"`
}

type EditVote struct {
	User *User        `json:"user,omitempty"`
	Date time.Time    `json:"date"`
	Vote VoteTypeEnum `json:"vote"`
}

type EditVoteInput struct {
	ID   string       `json:"id"`
	Vote VoteTypeEnum `json:"vote"`
}

type EyeColorCriterionInput struct {
	Value    *EyeColorEnum     `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type Fingerprint struct {
	Hash          string               `json:"hash"`
	Algorithm     FingerprintAlgorithm `json:"algorithm"`
	Duration      int                  `json:"duration"`
	Submissions   int                  `json:"submissions"`
	Created       time.Time            `json:"created"`
	Updated       time.Time            `json:"updated"`
	UserSubmitted bool                 `json:"user_submitted"`
}

type FingerprintEditInput struct {
	UserIds     []string             `json:"user_ids,omitempty"`
	Hash        string               `json:"hash"`
	Algorithm   FingerprintAlgorithm `json:"algorithm"`
	Duration    int                  `json:"duration"`
	Created     time.Time            `json:"created"`
	Submissions *int                 `json:"submissions,omitempty"`
	Updated     *time.Time           `json:"updated,omitempty"`
}

type FingerprintInput struct {
	// assumes current user if omitted. Ignored for non-modify Users
	UserIds   []string             `json:"user_ids,omitempty"`
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type FingerprintQueryInput struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
}

type FingerprintSubmission struct {
	SceneID     string            `json:"scene_id"`
	Fingerprint *FingerprintInput `json:"fingerprint"`
	Unmatch     *bool             `json:"unmatch,omitempty"`
}

type FuzzyDate struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type GenerateInviteCodeInput struct {
	Keys *int `json:"keys,omitempty"`
	Uses *int `json:"uses,omitempty"`
	TTL  *int `json:"ttl,omitempty"`
}

type GrantInviteInput struct {
	UserID string `json:"user_id"`
	Amount int    `json:"amount"`
}

type HairColorCriterionInput struct {
	Value    *HairColorEnum    `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type IDCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Image struct {
	ID     string `json:"id"`
	URL    string `json:"url"`
	Width  int    `json:"width"`
	Height int    `json:"height"`
}

type ImageCreateInput struct {
	URL  *string         `json:"url,omitempty"`
	File *graphql.Upload `json:"file,omitempty"`
}

type ImageDestroyInput struct {
	ID string `json:"id"`
}

type ImageUpdateInput struct {
	ID  string  `json:"id"`
	URL *string `json:"url,omitempty"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type InviteKey struct {
	ID      string     `json:"id"`
	Uses    *int       `json:"uses,omitempty"`
	Expires *time.Time `json:"expires,omitempty"`
}

type Measurements struct {
	CupSize  *string `json:"cup_size,omitempty"`
	BandSize *int    `json:"band_size,omitempty"`
	Waist    *int    `json:"waist,omitempty"`
	Hip      *int    `json:"hip,omitempty"`
}

type MultiIDCriterionInput struct {
	Value    []string          `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type MultiStringCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Mutation struct {
}

type NewUserInput struct {
	Email     string  `json:"email"`
	InviteKey *string `json:"invite_key,omitempty"`
}

type Performer struct {
	ID             string         `json:"id"`
	Name           string         `json:"name"`
	Disambiguation *string        `json:"disambiguation,omitempty"`
	Aliases        []string       `json:"aliases"`
	Gender         *GenderEnum    `json:"gender,omitempty"`
	Urls           []*URL         `json:"urls"`
	Birthdate      *FuzzyDate     `json:"birthdate,omitempty"`
	BirthDate      *string        `json:"birth_date,omitempty"`
	Age            *int           `json:"age,omitempty"`
	Ethnicity      *EthnicityEnum `json:"ethnicity,omitempty"`
	Country        *string        `json:"country,omitempty"`
	EyeColor       *EyeColorEnum  `json:"eye_color,omitempty"`
	HairColor      *HairColorEnum `json:"hair_color,omitempty"`
	// Height in cm
	Height          *int                `json:"height,omitempty"`
	Measurements    *Measurements       `json:"measurements"`
	CupSize         *string             `json:"cup_size,omitempty"`
	BandSize        *int                `json:"band_size,omitempty"`
	WaistSize       *int                `json:"waist_size,omitempty"`
	HipSize         *int                `json:"hip_size,omitempty"`
	BreastType      *BreastTypeEnum     `json:"breast_type,omitempty"`
	CareerStartYear *int                `json:"career_start_year,omitempty"`
	CareerEndYear   *int                `json:"career_end_year,omitempty"`
	Tattoos         []*BodyModification `json:"tattoos,omitempty"`
	Piercings       []*BodyModification `json:"piercings,omitempty"`
	Images          []*Image            `json:"images"`
	Deleted         bool                `json:"deleted"`
	Edits           []*Edit             `json:"edits"`
	SceneCount      int                 `json:"scene_count"`
	Scenes          []*Scene            `json:"scenes"`
	MergedIds       []string            `json:"merged_ids"`
	Studios         []*PerformerStudio  `json:"studios"`
	IsFavorite      bool                `json:"is_favorite"`
	Created         time.Time           `json:"created"`
	Updated         time.Time           `json:"updated"`
}

func (Performer) IsEditTarget() {}

func (Performer) IsSceneDraftPerformer() {}

type PerformerAppearance struct {
	Performer *Performer `json:"performer"`
	// Performing as alias
	As *string `json:"as,omitempty"`
}

type PerformerAppearanceInput struct {
	PerformerID string `json:"performer_id"`
	// Performing as alias
	As *string `json:"as,omitempty"`
}

type PerformerCreateInput struct {
	Name            string                   `json:"name"`
	Disambiguation  *string                  `json:"disambiguation,omitempty"`
	Aliases         []string                 `json:"aliases,omitempty"`
	Gender          *GenderEnum              `json:"gender,omitempty"`
	Urls            []*URLInput              `json:"urls,omitempty"`
	Birthdate       *string                  `json:"birthdate,omitempty"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity,omitempty"`
	Country         *string                  `json:"country,omitempty"`
	EyeColor        *EyeColorEnum            `json:"eye_color,omitempty"`
	HairColor       *HairColorEnum           `json:"hair_color,omitempty"`
	Height          *int                     `json:"height,omitempty"`
	CupSize         *string                  `json:"cup_size,omitempty"`
	BandSize        *int                     `json:"band_size,omitempty"`
	WaistSize       *int                     `json:"waist_size,omitempty"`
	HipSize         *int                     `json:"hip_size,omitempty"`
	BreastType      *BreastTypeEnum          `json:"breast_type,omitempty"`
	CareerStartYear *int                     `json:"career_start_year,omitempty"`
	CareerEndYear   *int                     `json:"career_end_year,omitempty"`
	Tattoos         []*BodyModificationInput `json:"tattoos,omitempty"`
	Piercings       []*BodyModificationInput `json:"piercings,omitempty"`
	ImageIds        []string                 `json:"image_ids,omitempty"`
	DraftID         *string                  `json:"draft_id,omitempty"`
}

type PerformerDestroyInput struct {
	ID string `json:"id"`
}

type PerformerDraft struct {
	ID              *string  `json:"id,omitempty"`
	Name            string   `json:"name"`
	Disambiguation  *string  `json:"disambiguation,omitempty"`
	Aliases         *string  `json:"aliases,omitempty"`
	Gender          *string  `json:"gender,omitempty"`
	Birthdate       *string  `json:"birthdate,omitempty"`
	Urls            []string `json:"urls,omitempty"`
	Ethnicity       *string  `json:"ethnicity,omitempty"`
	Country         *string  `json:"country,omitempty"`
	EyeColor        *string  `json:"eye_color,omitempty"`
	HairColor       *string  `json:"hair_color,omitempty"`
	Height          *string  `json:"height,omitempty"`
	Measurements    *string  `json:"measurements,omitempty"`
	BreastType      *string  `json:"breast_type,omitempty"`
	Tattoos         *string  `json:"tattoos,omitempty"`
	Piercings       *string  `json:"piercings,omitempty"`
	CareerStartYear *int     `json:"career_start_year,omitempty"`
	CareerEndYear   *int     `json:"career_end_year,omitempty"`
	Image           *Image   `json:"image,omitempty"`
}

func (PerformerDraft) IsDraftData() {}

type PerformerDraftInput struct {
	ID              *string         `json:"id,omitempty"`
	Disambiguation  *string         `json:"disambiguation,omitempty"`
	Name            string          `json:"name"`
	Aliases         *string         `json:"aliases,omitempty"`
	Gender          *string         `json:"gender,omitempty"`
	Birthdate       *string         `json:"birthdate,omitempty"`
	Urls            []string        `json:"urls,omitempty"`
	Ethnicity       *string         `json:"ethnicity,omitempty"`
	Country         *string         `json:"country,omitempty"`
	EyeColor        *string         `json:"eye_color,omitempty"`
	HairColor       *string         `json:"hair_color,omitempty"`
	Height          *string         `json:"height,omitempty"`
	Measurements    *string         `json:"measurements,omitempty"`
	BreastType      *string         `json:"breast_type,omitempty"`
	Tattoos         *string         `json:"tattoos,omitempty"`
	Piercings       *string         `json:"piercings,omitempty"`
	CareerStartYear *int            `json:"career_start_year,omitempty"`
	CareerEndYear   *int            `json:"career_end_year,omitempty"`
	Image           *graphql.Upload `json:"image,omitempty"`
}

type PerformerEdit struct {
	Name           *string        `json:"name,omitempty"`
	Disambiguation *string        `json:"disambiguation,omitempty"`
	AddedAliases   []string       `json:"added_aliases,omitempty"`
	RemovedAliases []string       `json:"removed_aliases,omitempty"`
	Gender         *GenderEnum    `json:"gender,omitempty"`
	AddedUrls      []*URL         `json:"added_urls,omitempty"`
	RemovedUrls    []*URL         `json:"removed_urls,omitempty"`
	Birthdate      *string        `json:"birthdate,omitempty"`
	Ethnicity      *EthnicityEnum `json:"ethnicity,omitempty"`
	Country        *string        `json:"country,omitempty"`
	EyeColor       *EyeColorEnum  `json:"eye_color,omitempty"`
	HairColor      *HairColorEnum `json:"hair_color,omitempty"`
	// Height in cm
	Height           *int                `json:"height,omitempty"`
	CupSize          *string             `json:"cup_size,omitempty"`
	BandSize         *int                `json:"band_size,omitempty"`
	WaistSize        *int                `json:"waist_size,omitempty"`
	HipSize          *int                `json:"hip_size,omitempty"`
	BreastType       *BreastTypeEnum     `json:"breast_type,omitempty"`
	CareerStartYear  *int                `json:"career_start_year,omitempty"`
	CareerEndYear    *int                `json:"career_end_year,omitempty"`
	AddedTattoos     []*BodyModification `json:"added_tattoos,omitempty"`
	RemovedTattoos   []*BodyModification `json:"removed_tattoos,omitempty"`
	AddedPiercings   []*BodyModification `json:"added_piercings,omitempty"`
	RemovedPiercings []*BodyModification `json:"removed_piercings,omitempty"`
	AddedImages      []*Image            `json:"added_images,omitempty"`
	RemovedImages    []*Image            `json:"removed_images,omitempty"`
	DraftID          *string             `json:"draft_id,omitempty"`
	Aliases          []string            `json:"aliases"`
	Urls             []*URL              `json:"urls"`
	Images           []*Image            `json:"images"`
	Tattoos          []*BodyModification `json:"tattoos"`
	Piercings        []*BodyModification `json:"piercings"`
}

func (PerformerEdit) IsEditDetails() {}

type PerformerEditDetailsInput struct {
	Name            *string                  `json:"name,omitempty"`
	Disambiguation  *string                  `json:"disambiguation,omitempty"`
	Aliases         []string                 `json:"aliases,omitempty"`
	Gender          *GenderEnum              `json:"gender,omitempty"`
	Urls            []*URLInput              `json:"urls,omitempty"`
	Birthdate       *string                  `json:"birthdate,omitempty"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity,omitempty"`
	Country         *string                  `json:"country,omitempty"`
	EyeColor        *EyeColorEnum            `json:"eye_color,omitempty"`
	HairColor       *HairColorEnum           `json:"hair_color,omitempty"`
	Height          *int                     `json:"height,omitempty"`
	CupSize         *string                  `json:"cup_size,omitempty"`
	BandSize        *int                     `json:"band_size,omitempty"`
	WaistSize       *int                     `json:"waist_size,omitempty"`
	HipSize         *int                     `json:"hip_size,omitempty"`
	BreastType      *BreastTypeEnum          `json:"breast_type,omitempty"`
	CareerStartYear *int                     `json:"career_start_year,omitempty"`
	CareerEndYear   *int                     `json:"career_end_year,omitempty"`
	Tattoos         []*BodyModificationInput `json:"tattoos,omitempty"`
	Piercings       []*BodyModificationInput `json:"piercings,omitempty"`
	ImageIds        []string                 `json:"image_ids,omitempty"`
	DraftID         *string                  `json:"draft_id,omitempty"`
}

type PerformerEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *PerformerEditDetailsInput `json:"details,omitempty"`
	// Controls aliases modification for merges and name modifications
	Options *PerformerEditOptionsInput `json:"options,omitempty"`
}

type PerformerEditOptions struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases bool `json:"set_modify_aliases"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases bool `json:"set_merge_aliases"`
}

type PerformerEditOptionsInput struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases *bool `json:"set_modify_aliases,omitempty"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases *bool `json:"set_merge_aliases,omitempty"`
}

type PerformerQueryInput struct {
	// Searches name and disambiguation - assumes like query unless quoted
	Names *string `json:"names,omitempty"`
	// Searches name only - assumes like query unless quoted
	Name *string `json:"name,omitempty"`
	// Search aliases only - assumes like query unless quoted
	Alias          *string               `json:"alias,omitempty"`
	Disambiguation *StringCriterionInput `json:"disambiguation,omitempty"`
	Gender         *GenderFilterEnum     `json:"gender,omitempty"`
	// Filter to search urls - assumes like query unless quoted
	URL             *string                         `json:"url,omitempty"`
	Birthdate       *DateCriterionInput             `json:"birthdate,omitempty"`
	BirthYear       *IntCriterionInput              `json:"birth_year,omitempty"`
	Age             *IntCriterionInput              `json:"age,omitempty"`
	Ethnicity       *EthnicityFilterEnum            `json:"ethnicity,omitempty"`
	Country         *StringCriterionInput           `json:"country,omitempty"`
	EyeColor        *EyeColorCriterionInput         `json:"eye_color,omitempty"`
	HairColor       *HairColorCriterionInput        `json:"hair_color,omitempty"`
	Height          *IntCriterionInput              `json:"height,omitempty"`
	CupSize         *StringCriterionInput           `json:"cup_size,omitempty"`
	BandSize        *IntCriterionInput              `json:"band_size,omitempty"`
	WaistSize       *IntCriterionInput              `json:"waist_size,omitempty"`
	HipSize         *IntCriterionInput              `json:"hip_size,omitempty"`
	BreastType      *BreastTypeCriterionInput       `json:"breast_type,omitempty"`
	CareerStartYear *IntCriterionInput              `json:"career_start_year,omitempty"`
	CareerEndYear   *IntCriterionInput              `json:"career_end_year,omitempty"`
	Tattoos         *BodyModificationCriterionInput `json:"tattoos,omitempty"`
	Piercings       *BodyModificationCriterionInput `json:"piercings,omitempty"`
	// Filter by performerfavorite status for the current user
	IsFavorite *bool `json:"is_favorite,omitempty"`
	// Filter by a performer they have performed in scenes with
	PerformedWith *string `json:"performed_with,omitempty"`
	// Filter by a studio
	StudioID  *string           `json:"studio_id,omitempty"`
	Page      int               `json:"page"`
	PerPage   int               `json:"per_page"`
	Direction SortDirectionEnum `json:"direction"`
	Sort      PerformerSortEnum `json:"sort"`
}

type PerformerScenesInput struct {
	// Filter by another performer that also performs in the scenes
	PerformedWith *string `json:"performed_with,omitempty"`
	// Filter by a studio
	StudioID *string `json:"studio_id,omitempty"`
	// Filter by tags
	Tags *MultiIDCriterionInput `json:"tags,omitempty"`
}

type PerformerStudio struct {
	Studio     *Studio `json:"studio"`
	SceneCount int     `json:"scene_count"`
}

type PerformerUpdateInput struct {
	ID              string                   `json:"id"`
	Name            *string                  `json:"name,omitempty"`
	Disambiguation  *string                  `json:"disambiguation,omitempty"`
	Aliases         []string                 `json:"aliases,omitempty"`
	Gender          *GenderEnum              `json:"gender,omitempty"`
	Urls            []*URLInput              `json:"urls,omitempty"`
	Birthdate       *string                  `json:"birthdate,omitempty"`
	Ethnicity       *EthnicityEnum           `json:"ethnicity,omitempty"`
	Country         *string                  `json:"country,omitempty"`
	EyeColor        *EyeColorEnum            `json:"eye_color,omitempty"`
	HairColor       *HairColorEnum           `json:"hair_color,omitempty"`
	Height          *int                     `json:"height,omitempty"`
	CupSize         *string                  `json:"cup_size,omitempty"`
	BandSize        *int                     `json:"band_size,omitempty"`
	WaistSize       *int                     `json:"waist_size,omitempty"`
	HipSize         *int                     `json:"hip_size,omitempty"`
	BreastType      *BreastTypeEnum          `json:"breast_type,omitempty"`
	CareerStartYear *int                     `json:"career_start_year,omitempty"`
	CareerEndYear   *int                     `json:"career_end_year,omitempty"`
	Tattoos         []*BodyModificationInput `json:"tattoos,omitempty"`
	Piercings       []*BodyModificationInput `json:"piercings,omitempty"`
	ImageIds        []string                 `json:"image_ids,omitempty"`
}

// The query root for this schema
type Query struct {
}

type QueryEditsResultType struct {
	Count int     `json:"count"`
	Edits []*Edit `json:"edits"`
}

type QueryExistingSceneInput struct {
	Title        *string             `json:"title,omitempty"`
	StudioID     *string             `json:"studio_id,omitempty"`
	Fingerprints []*FingerprintInput `json:"fingerprints"`
}

type QueryExistingSceneResult struct {
	Edits  []*Edit  `json:"edits"`
	Scenes []*Scene `json:"scenes"`
}

type QueryPerformersResultType struct {
	Count      int          `json:"count"`
	Performers []*Performer `json:"performers"`
}

type QueryScenesResultType struct {
	Count  int      `json:"count"`
	Scenes []*Scene `json:"scenes"`
}

type QuerySitesResultType struct {
	Count int     `json:"count"`
	Sites []*Site `json:"sites"`
}

type QueryStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type QueryTagCategoriesResultType struct {
	Count         int            `json:"count"`
	TagCategories []*TagCategory `json:"tag_categories"`
}

type QueryTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type QueryUsersResultType struct {
	Count int     `json:"count"`
	Users []*User `json:"users"`
}

type ResetPasswordInput struct {
	Email string `json:"email"`
}

type RevokeInviteInput struct {
	UserID string `json:"user_id"`
	Amount int    `json:"amount"`
}

type RoleCriterionInput struct {
	Value    []RoleEnum        `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Scene struct {
	ID           string                 `json:"id"`
	Title        *string                `json:"title,omitempty"`
	Details      *string                `json:"details,omitempty"`
	Date         *string                `json:"date,omitempty"`
	ReleaseDate  *string                `json:"release_date,omitempty"`
	Urls         []*URL                 `json:"urls"`
	Studio       *Studio                `json:"studio,omitempty"`
	Tags         []*Tag                 `json:"tags"`
	Images       []*Image               `json:"images"`
	Performers   []*PerformerAppearance `json:"performers"`
	Fingerprints []*Fingerprint         `json:"fingerprints"`
	Duration     *int                   `json:"duration,omitempty"`
	Director     *string                `json:"director,omitempty"`
	Code         *string                `json:"code,omitempty"`
	Deleted      bool                   `json:"deleted"`
	Edits        []*Edit                `json:"edits"`
	Created      time.Time              `json:"created"`
	Updated      time.Time              `json:"updated"`
}

func (Scene) IsEditTarget() {}

type SceneCreateInput struct {
	Title        *string                     `json:"title,omitempty"`
	Details      *string                     `json:"details,omitempty"`
	Urls         []*URLInput                 `json:"urls,omitempty"`
	Date         string                      `json:"date"`
	StudioID     *string                     `json:"studio_id,omitempty"`
	Performers   []*PerformerAppearanceInput `json:"performers,omitempty"`
	TagIds       []string                    `json:"tag_ids,omitempty"`
	ImageIds     []string                    `json:"image_ids,omitempty"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints"`
	Duration     *int                        `json:"duration,omitempty"`
	Director     *string                     `json:"director,omitempty"`
	Code         *string                     `json:"code,omitempty"`
}

type SceneDestroyInput struct {
	ID string `json:"id"`
}

type SceneDraft struct {
	ID           *string               `json:"id,omitempty"`
	Title        *string               `json:"title,omitempty"`
	Code         *string               `json:"code,omitempty"`
	Details      *string               `json:"details,omitempty"`
	Director     *string               `json:"director,omitempty"`
	URL          *URL                  `json:"url,omitempty"`
	Date         *string               `json:"date,omitempty"`
	Studio       SceneDraftStudio      `json:"studio,omitempty"`
	Performers   []SceneDraftPerformer `json:"performers"`
	Tags         []SceneDraftTag       `json:"tags,omitempty"`
	Image        *Image                `json:"image,omitempty"`
	Fingerprints []*DraftFingerprint   `json:"fingerprints"`
}

func (SceneDraft) IsDraftData() {}

type SceneEdit struct {
	Title       *string `json:"title,omitempty"`
	Details     *string `json:"details,omitempty"`
	AddedUrls   []*URL  `json:"added_urls,omitempty"`
	RemovedUrls []*URL  `json:"removed_urls,omitempty"`
	Date        *string `json:"date,omitempty"`
	Studio      *Studio `json:"studio,omitempty"`
	// Added or modified performer appearance entries
	AddedPerformers     []*PerformerAppearance `json:"added_performers,omitempty"`
	RemovedPerformers   []*PerformerAppearance `json:"removed_performers,omitempty"`
	AddedTags           []*Tag                 `json:"added_tags,omitempty"`
	RemovedTags         []*Tag                 `json:"removed_tags,omitempty"`
	AddedImages         []*Image               `json:"added_images,omitempty"`
	RemovedImages       []*Image               `json:"removed_images,omitempty"`
	AddedFingerprints   []*Fingerprint         `json:"added_fingerprints,omitempty"`
	RemovedFingerprints []*Fingerprint         `json:"removed_fingerprints,omitempty"`
	Duration            *int                   `json:"duration,omitempty"`
	Director            *string                `json:"director,omitempty"`
	Code                *string                `json:"code,omitempty"`
	DraftID             *string                `json:"draft_id,omitempty"`
	Urls                []*URL                 `json:"urls"`
	Performers          []*PerformerAppearance `json:"performers"`
	Tags                []*Tag                 `json:"tags"`
	Images              []*Image               `json:"images"`
	Fingerprints        []*Fingerprint         `json:"fingerprints"`
}

func (SceneEdit) IsEditDetails() {}

type SceneEditDetailsInput struct {
	Title        *string                     `json:"title,omitempty"`
	Details      *string                     `json:"details,omitempty"`
	Urls         []*URLInput                 `json:"urls,omitempty"`
	Date         *string                     `json:"date,omitempty"`
	StudioID     *string                     `json:"studio_id,omitempty"`
	Performers   []*PerformerAppearanceInput `json:"performers,omitempty"`
	TagIds       []string                    `json:"tag_ids,omitempty"`
	ImageIds     []string                    `json:"image_ids,omitempty"`
	Duration     *int                        `json:"duration,omitempty"`
	Director     *string                     `json:"director,omitempty"`
	Code         *string                     `json:"code,omitempty"`
	Fingerprints []*FingerprintInput         `json:"fingerprints,omitempty"`
	DraftID      *string                     `json:"draft_id,omitempty"`
}

type SceneEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *SceneEditDetailsInput `json:"details,omitempty"`
}

type SceneQueryInput struct {
	// Filter to search title and details - assumes like query unless quoted
	Text *string `json:"text,omitempty"`
	// Filter to search title - assumes like query unless quoted
	Title *string `json:"title,omitempty"`
	// Filter to search urls - assumes like query unless quoted
	URL *string `json:"url,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter to only include scenes with this studio
	Studios *MultiIDCriterionInput `json:"studios,omitempty"`
	// Filter to only include scenes with this studio as primary or parent
	ParentStudio *string `json:"parentStudio,omitempty"`
	// Filter to only include scenes with these tags
	Tags *MultiIDCriterionInput `json:"tags,omitempty"`
	// Filter to only include scenes with these performers
	Performers *MultiIDCriterionInput `json:"performers,omitempty"`
	// Filter to include scenes with performer appearing as alias
	Alias *StringCriterionInput `json:"alias,omitempty"`
	// Filter to only include scenes with these fingerprints
	Fingerprints *MultiStringCriterionInput `json:"fingerprints,omitempty"`
	// Filter by favorited entity
	Favorites *FavoriteFilter `json:"favorites,omitempty"`
	// Filter to scenes with fingerprints submitted by the user
	HasFingerprintSubmissions *bool             `json:"has_fingerprint_submissions,omitempty"`
	Page                      int               `json:"page"`
	PerPage                   int               `json:"per_page"`
	Direction                 SortDirectionEnum `json:"direction"`
	Sort                      SceneSortEnum     `json:"sort"`
}

type SceneUpdateInput struct {
	ID           string                      `json:"id"`
	Title        *string                     `json:"title,omitempty"`
	Details      *string                     `json:"details,omitempty"`
	Urls         []*URLInput                 `json:"urls,omitempty"`
	Date         *string                     `json:"date,omitempty"`
	StudioID     *string                     `json:"studio_id,omitempty"`
	Performers   []*PerformerAppearanceInput `json:"performers,omitempty"`
	TagIds       []string                    `json:"tag_ids,omitempty"`
	ImageIds     []string                    `json:"image_ids,omitempty"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints,omitempty"`
	Duration     *int                        `json:"duration,omitempty"`
	Director     *string                     `json:"director,omitempty"`
	Code         *string                     `json:"code,omitempty"`
}

type Site struct {
	ID          string              `json:"id"`
	Name        string              `json:"name"`
	Description *string             `json:"description,omitempty"`
	URL         *string             `json:"url,omitempty"`
	Regex       *string             `json:"regex,omitempty"`
	ValidTypes  []ValidSiteTypeEnum `json:"valid_types"`
	Icon        string              `json:"icon"`
	Created     time.Time           `json:"created"`
	Updated     time.Time           `json:"updated"`
}

type SiteCreateInput struct {
	Name        string              `json:"name"`
	Description *string             `json:"description,omitempty"`
	URL         *string             `json:"url,omitempty"`
	Regex       *string             `json:"regex,omitempty"`
	ValidTypes  []ValidSiteTypeEnum `json:"valid_types"`
}

type SiteDestroyInput struct {
	ID string `json:"id"`
}

type SiteUpdateInput struct {
	ID          string              `json:"id"`
	Name        string              `json:"name"`
	Description *string             `json:"description,omitempty"`
	URL         *string             `json:"url,omitempty"`
	Regex       *string             `json:"regex,omitempty"`
	ValidTypes  []ValidSiteTypeEnum `json:"valid_types"`
}

type StashBoxConfig struct {
	HostURL                    string `json:"host_url"`
	RequireInvite              bool   `json:"require_invite"`
	RequireActivation          bool   `json:"require_activation"`
	VotePromotionThreshold     *int   `json:"vote_promotion_threshold,omitempty"`
	VoteApplicationThreshold   int    `json:"vote_application_threshold"`
	VotingPeriod               int    `json:"voting_period"`
	MinDestructiveVotingPeriod int    `json:"min_destructive_voting_period"`
	VoteCronInterval           string `json:"vote_cron_interval"`
	GuidelinesURL              string `json:"guidelines_url"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Studio struct {
	ID           string                     `json:"id"`
	Name         string                     `json:"name"`
	Urls         []*URL                     `json:"urls"`
	Parent       *Studio                    `json:"parent,omitempty"`
	ChildStudios []*Studio                  `json:"child_studios"`
	Images       []*Image                   `json:"images"`
	Deleted      bool                       `json:"deleted"`
	IsFavorite   bool                       `json:"is_favorite"`
	Created      time.Time                  `json:"created"`
	Updated      time.Time                  `json:"updated"`
	Performers   *QueryPerformersResultType `json:"performers"`
}

func (Studio) IsEditTarget() {}

func (Studio) IsSceneDraftStudio() {}

type StudioCreateInput struct {
	Name     string      `json:"name"`
	Urls     []*URLInput `json:"urls,omitempty"`
	ParentID *string     `json:"parent_id,omitempty"`
	ImageIds []string    `json:"image_ids,omitempty"`
}

type StudioDestroyInput struct {
	ID string `json:"id"`
}

type StudioEdit struct {
	Name *string `json:"name,omitempty"`
	// Added and modified URLs
	AddedUrls     []*URL   `json:"added_urls,omitempty"`
	RemovedUrls   []*URL   `json:"removed_urls,omitempty"`
	Parent        *Studio  `json:"parent,omitempty"`
	AddedImages   []*Image `json:"added_images,omitempty"`
	RemovedImages []*Image `json:"removed_images,omitempty"`
	Images        []*Image `json:"images"`
	Urls          []*URL   `json:"urls"`
}

func (StudioEdit) IsEditDetails() {}

type StudioEditDetailsInput struct {
	Name     *string     `json:"name,omitempty"`
	Urls     []*URLInput `json:"urls,omitempty"`
	ParentID *string     `json:"parent_id,omitempty"`
	ImageIds []string    `json:"image_ids,omitempty"`
}

type StudioEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *StudioEditDetailsInput `json:"details,omitempty"`
}

type StudioQueryInput struct {
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name,omitempty"`
	// Filter to search studio and parent studio name - assumes like query unless quoted
	Names *string `json:"names,omitempty"`
	// Filter to search url - assumes like query unless quoted
	URL       *string           `json:"url,omitempty"`
	Parent    *IDCriterionInput `json:"parent,omitempty"`
	HasParent *bool             `json:"has_parent,omitempty"`
	// Filter by studio favorite status for the current user
	IsFavorite *bool             `json:"is_favorite,omitempty"`
	Page       int               `json:"page"`
	PerPage    int               `json:"per_page"`
	Direction  SortDirectionEnum `json:"direction"`
	Sort       StudioSortEnum    `json:"sort"`
}

type StudioUpdateInput struct {
	ID       string      `json:"id"`
	Name     *string     `json:"name,omitempty"`
	Urls     []*URLInput `json:"urls,omitempty"`
	ParentID *string     `json:"parent_id,omitempty"`
	ImageIds []string    `json:"image_ids,omitempty"`
}

type Tag struct {
	ID          string       `json:"id"`
	Name        string       `json:"name"`
	Description *string      `json:"description,omitempty"`
	Aliases     []string     `json:"aliases"`
	Deleted     bool         `json:"deleted"`
	Edits       []*Edit      `json:"edits"`
	Category    *TagCategory `json:"category,omitempty"`
	Created     time.Time    `json:"created"`
	Updated     time.Time    `json:"updated"`
}

func (Tag) IsEditTarget() {}

func (Tag) IsSceneDraftTag() {}

type TagCategory struct {
	ID          string       `json:"id"`
	Name        string       `json:"name"`
	Group       TagGroupEnum `json:"group"`
	Description *string      `json:"description,omitempty"`
}

type TagCategoryCreateInput struct {
	Name        string       `json:"name"`
	Group       TagGroupEnum `json:"group"`
	Description *string      `json:"description,omitempty"`
}

type TagCategoryDestroyInput struct {
	ID string `json:"id"`
}

type TagCategoryUpdateInput struct {
	ID          string        `json:"id"`
	Name        *string       `json:"name,omitempty"`
	Group       *TagGroupEnum `json:"group,omitempty"`
	Description *string       `json:"description,omitempty"`
}

type TagCreateInput struct {
	Name        string   `json:"name"`
	Description *string  `json:"description,omitempty"`
	Aliases     []string `json:"aliases,omitempty"`
	CategoryID  *string  `json:"category_id,omitempty"`
}

type TagDestroyInput struct {
	ID string `json:"id"`
}

type TagEdit struct {
	Name           *string      `json:"name,omitempty"`
	Description    *string      `json:"description,omitempty"`
	AddedAliases   []string     `json:"added_aliases,omitempty"`
	RemovedAliases []string     `json:"removed_aliases,omitempty"`
	Category       *TagCategory `json:"category,omitempty"`
	Aliases        []string     `json:"aliases"`
}

func (TagEdit) IsEditDetails() {}

type TagEditDetailsInput struct {
	Name        *string  `json:"name,omitempty"`
	Description *string  `json:"description,omitempty"`
	Aliases     []string `json:"aliases,omitempty"`
	CategoryID  *string  `json:"category_id,omitempty"`
}

type TagEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *TagEditDetailsInput `json:"details,omitempty"`
}

type TagQueryInput struct {
	// Filter to search name, aliases and description - assumes like query unless quoted
	Text *string `json:"text,omitempty"`
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names,omitempty"`
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name,omitempty"`
	// Filter to category ID
	CategoryID *string           `json:"category_id,omitempty"`
	Page       int               `json:"page"`
	PerPage    int               `json:"per_page"`
	Direction  SortDirectionEnum `json:"direction"`
	Sort       TagSortEnum       `json:"sort"`
}

type TagUpdateInput struct {
	ID          string   `json:"id"`
	Name        *string  `json:"name,omitempty"`
	Description *string  `json:"description,omitempty"`
	Aliases     []string `json:"aliases,omitempty"`
	CategoryID  *string  `json:"category_id,omitempty"`
}

type URL struct {
	URL  string `json:"url"`
	Type string `json:"type"`
	Site *Site  `json:"site"`
}

type URLInput struct {
	URL    string `json:"url"`
	SiteID string `json:"site_id"`
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// Should not be visible to other users
	Roles []RoleEnum `json:"roles,omitempty"`
	// Should not be visible to other users
	Email *string `json:"email,omitempty"`
	// Should not be visible to other users
	APIKey *string `json:"api_key,omitempty"`
	//  Vote counts by type
	VoteCount *UserVoteCount `json:"vote_count"`
	//  Edit counts by status
	EditCount *UserEditCount `json:"edit_count"`
	// Calls to the API from this user over a configurable time period
	APICalls          int          `json:"api_calls"`
	InvitedBy         *User        `json:"invited_by,omitempty"`
	InviteTokens      *int         `json:"invite_tokens,omitempty"`
	ActiveInviteCodes []string     `json:"active_invite_codes,omitempty"`
	InviteCodes       []*InviteKey `json:"invite_codes,omitempty"`
}

type UserChangePasswordInput struct {
	// Password in plain text
	ExistingPassword *string `json:"existing_password,omitempty"`
	NewPassword      string  `json:"new_password"`
	ResetKey         *string `json:"reset_key,omitempty"`
}

type UserCreateInput struct {
	Name string `json:"name"`
	// Password in plain text
	Password    string     `json:"password"`
	Roles       []RoleEnum `json:"roles"`
	Email       string     `json:"email"`
	InvitedByID *string    `json:"invited_by_id,omitempty"`
}

type UserDestroyInput struct {
	ID string `json:"id"`
}

type UserEditCount struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	Pending           int `json:"pending"`
	ImmediateAccepted int `json:"immediate_accepted"`
	ImmediateRejected int `json:"immediate_rejected"`
	Failed            int `json:"failed"`
	Canceled          int `json:"canceled"`
}

type UserQueryInput struct {
	// Filter to search user name - assumes like query unless quoted
	Name *string `json:"name,omitempty"`
	// Filter to search email - assumes like query unless quoted
	Email *string `json:"email,omitempty"`
	// Filter by roles
	Roles *RoleCriterionInput `json:"roles,omitempty"`
	// Filter by api key
	APIKey *string `json:"apiKey,omitempty"`
	// Filter by successful edits
	SuccessfulEdits *IntCriterionInput `json:"successful_edits,omitempty"`
	// Filter by unsuccessful edits
	UnsuccessfulEdits *IntCriterionInput `json:"unsuccessful_edits,omitempty"`
	// Filter by votes on successful edits
	SuccessfulVotes *IntCriterionInput `json:"successful_votes,omitempty"`
	// Filter by votes on unsuccessful edits
	UnsuccessfulVotes *IntCriterionInput `json:"unsuccessful_votes,omitempty"`
	// Filter by number of API calls
	APICalls *IntCriterionInput `json:"api_calls,omitempty"`
	// Filter by user that invited
	InvitedBy *string `json:"invited_by,omitempty"`
	Page      int     `json:"page"`
	PerPage   int     `json:"per_page"`
}

type UserUpdateInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
	// Password in plain text
	Password *string    `json:"password,omitempty"`
	Roles    []RoleEnum `json:"roles,omitempty"`
	Email    *string    `json:"email,omitempty"`
}

type UserVoteCount struct {
	Abstain         int `json:"abstain"`
	Accept          int `json:"accept"`
	Reject          int `json:"reject"`
	ImmediateAccept int `json:"immediate_accept"`
	ImmediateReject int `json:"immediate_reject"`
}

type Version struct {
	Hash      string `json:"hash"`
	BuildTime string `json:"build_time"`
	BuildType string `json:"build_type"`
	Version   string `json:"version"`
}

type BreastTypeEnum string

const (
	BreastTypeEnumNatural BreastTypeEnum = "NATURAL"
	BreastTypeEnumFake    BreastTypeEnum = "FAKE"
	BreastTypeEnumNa      BreastTypeEnum = "NA"
)

var AllBreastTypeEnum = []BreastTypeEnum{
	BreastTypeEnumNatural,
	BreastTypeEnumFake,
	BreastTypeEnumNa,
}

func (e BreastTypeEnum) IsValid() bool {
	switch e {
	case BreastTypeEnumNatural, BreastTypeEnumFake, BreastTypeEnumNa:
		return true
	}
	return false
}

func (e BreastTypeEnum) String() string {
	return string(e)
}

func (e *BreastTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BreastTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BreastTypeEnum", str)
	}
	return nil
}

func (e BreastTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DateAccuracyEnum string

const (
	DateAccuracyEnumYear  DateAccuracyEnum = "YEAR"
	DateAccuracyEnumMonth DateAccuracyEnum = "MONTH"
	DateAccuracyEnumDay   DateAccuracyEnum = "DAY"
)

var AllDateAccuracyEnum = []DateAccuracyEnum{
	DateAccuracyEnumYear,
	DateAccuracyEnumMonth,
	DateAccuracyEnumDay,
}

func (e DateAccuracyEnum) IsValid() bool {
	switch e {
	case DateAccuracyEnumYear, DateAccuracyEnumMonth, DateAccuracyEnumDay:
		return true
	}
	return false
}

func (e DateAccuracyEnum) String() string {
	return string(e)
}

func (e *DateAccuracyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateAccuracyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateAccuracyEnum", str)
	}
	return nil
}

func (e DateAccuracyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EditSortEnum string

const (
	EditSortEnumCreatedAt EditSortEnum = "CREATED_AT"
	EditSortEnumUpdatedAt EditSortEnum = "UPDATED_AT"
	EditSortEnumClosedAt  EditSortEnum = "CLOSED_AT"
)

var AllEditSortEnum = []EditSortEnum{
	EditSortEnumCreatedAt,
	EditSortEnumUpdatedAt,
	EditSortEnumClosedAt,
}

func (e EditSortEnum) IsValid() bool {
	switch e {
	case EditSortEnumCreatedAt, EditSortEnumUpdatedAt, EditSortEnumClosedAt:
		return true
	}
	return false
}

func (e EditSortEnum) String() string {
	return string(e)
}

func (e *EditSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EditSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EditSortEnum", str)
	}
	return nil
}

func (e EditSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityEnum string

const (
	EthnicityEnumCaucasian     EthnicityEnum = "CAUCASIAN"
	EthnicityEnumBlack         EthnicityEnum = "BLACK"
	EthnicityEnumAsian         EthnicityEnum = "ASIAN"
	EthnicityEnumIndian        EthnicityEnum = "INDIAN"
	EthnicityEnumLatin         EthnicityEnum = "LATIN"
	EthnicityEnumMiddleEastern EthnicityEnum = "MIDDLE_EASTERN"
	EthnicityEnumMixed         EthnicityEnum = "MIXED"
	EthnicityEnumOther         EthnicityEnum = "OTHER"
)

var AllEthnicityEnum = []EthnicityEnum{
	EthnicityEnumCaucasian,
	EthnicityEnumBlack,
	EthnicityEnumAsian,
	EthnicityEnumIndian,
	EthnicityEnumLatin,
	EthnicityEnumMiddleEastern,
	EthnicityEnumMixed,
	EthnicityEnumOther,
}

func (e EthnicityEnum) IsValid() bool {
	switch e {
	case EthnicityEnumCaucasian, EthnicityEnumBlack, EthnicityEnumAsian, EthnicityEnumIndian, EthnicityEnumLatin, EthnicityEnumMiddleEastern, EthnicityEnumMixed, EthnicityEnumOther:
		return true
	}
	return false
}

func (e EthnicityEnum) String() string {
	return string(e)
}

func (e *EthnicityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityEnum", str)
	}
	return nil
}

func (e EthnicityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityFilterEnum string

const (
	EthnicityFilterEnumUnknown       EthnicityFilterEnum = "UNKNOWN"
	EthnicityFilterEnumCaucasian     EthnicityFilterEnum = "CAUCASIAN"
	EthnicityFilterEnumBlack         EthnicityFilterEnum = "BLACK"
	EthnicityFilterEnumAsian         EthnicityFilterEnum = "ASIAN"
	EthnicityFilterEnumIndian        EthnicityFilterEnum = "INDIAN"
	EthnicityFilterEnumLatin         EthnicityFilterEnum = "LATIN"
	EthnicityFilterEnumMiddleEastern EthnicityFilterEnum = "MIDDLE_EASTERN"
	EthnicityFilterEnumMixed         EthnicityFilterEnum = "MIXED"
	EthnicityFilterEnumOther         EthnicityFilterEnum = "OTHER"
)

var AllEthnicityFilterEnum = []EthnicityFilterEnum{
	EthnicityFilterEnumUnknown,
	EthnicityFilterEnumCaucasian,
	EthnicityFilterEnumBlack,
	EthnicityFilterEnumAsian,
	EthnicityFilterEnumIndian,
	EthnicityFilterEnumLatin,
	EthnicityFilterEnumMiddleEastern,
	EthnicityFilterEnumMixed,
	EthnicityFilterEnumOther,
}

func (e EthnicityFilterEnum) IsValid() bool {
	switch e {
	case EthnicityFilterEnumUnknown, EthnicityFilterEnumCaucasian, EthnicityFilterEnumBlack, EthnicityFilterEnumAsian, EthnicityFilterEnumIndian, EthnicityFilterEnumLatin, EthnicityFilterEnumMiddleEastern, EthnicityFilterEnumMixed, EthnicityFilterEnumOther:
		return true
	}
	return false
}

func (e EthnicityFilterEnum) String() string {
	return string(e)
}

func (e *EthnicityFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityFilterEnum", str)
	}
	return nil
}

func (e EthnicityFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EyeColorEnum string

const (
	EyeColorEnumBlue  EyeColorEnum = "BLUE"
	EyeColorEnumBrown EyeColorEnum = "BROWN"
	EyeColorEnumGrey  EyeColorEnum = "GREY"
	EyeColorEnumGreen EyeColorEnum = "GREEN"
	EyeColorEnumHazel EyeColorEnum = "HAZEL"
	EyeColorEnumRed   EyeColorEnum = "RED"
)

var AllEyeColorEnum = []EyeColorEnum{
	EyeColorEnumBlue,
	EyeColorEnumBrown,
	EyeColorEnumGrey,
	EyeColorEnumGreen,
	EyeColorEnumHazel,
	EyeColorEnumRed,
}

func (e EyeColorEnum) IsValid() bool {
	switch e {
	case EyeColorEnumBlue, EyeColorEnumBrown, EyeColorEnumGrey, EyeColorEnumGreen, EyeColorEnumHazel, EyeColorEnumRed:
		return true
	}
	return false
}

func (e EyeColorEnum) String() string {
	return string(e)
}

func (e *EyeColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EyeColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EyeColorEnum", str)
	}
	return nil
}

func (e EyeColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FavoriteFilter string

const (
	FavoriteFilterPerformer FavoriteFilter = "PERFORMER"
	FavoriteFilterStudio    FavoriteFilter = "STUDIO"
	FavoriteFilterAll       FavoriteFilter = "ALL"
)

var AllFavoriteFilter = []FavoriteFilter{
	FavoriteFilterPerformer,
	FavoriteFilterStudio,
	FavoriteFilterAll,
}

func (e FavoriteFilter) IsValid() bool {
	switch e {
	case FavoriteFilterPerformer, FavoriteFilterStudio, FavoriteFilterAll:
		return true
	}
	return false
}

func (e FavoriteFilter) String() string {
	return string(e)
}

func (e *FavoriteFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FavoriteFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FavoriteFilter", str)
	}
	return nil
}

func (e FavoriteFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FingerprintAlgorithm string

const (
	FingerprintAlgorithmMd5    FingerprintAlgorithm = "MD5"
	FingerprintAlgorithmOshash FingerprintAlgorithm = "OSHASH"
	FingerprintAlgorithmPhash  FingerprintAlgorithm = "PHASH"
)

var AllFingerprintAlgorithm = []FingerprintAlgorithm{
	FingerprintAlgorithmMd5,
	FingerprintAlgorithmOshash,
	FingerprintAlgorithmPhash,
}

func (e FingerprintAlgorithm) IsValid() bool {
	switch e {
	case FingerprintAlgorithmMd5, FingerprintAlgorithmOshash, FingerprintAlgorithmPhash:
		return true
	}
	return false
}

func (e FingerprintAlgorithm) String() string {
	return string(e)
}

func (e *FingerprintAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FingerprintAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FingerprintAlgorithm", str)
	}
	return nil
}

func (e FingerprintAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
	GenderEnumNonBinary         GenderEnum = "NON_BINARY"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
	GenderEnumNonBinary,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex, GenderEnumNonBinary:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderFilterEnum string

const (
	GenderFilterEnumUnknown           GenderFilterEnum = "UNKNOWN"
	GenderFilterEnumMale              GenderFilterEnum = "MALE"
	GenderFilterEnumFemale            GenderFilterEnum = "FEMALE"
	GenderFilterEnumTransgenderMale   GenderFilterEnum = "TRANSGENDER_MALE"
	GenderFilterEnumTransgenderFemale GenderFilterEnum = "TRANSGENDER_FEMALE"
	GenderFilterEnumIntersex          GenderFilterEnum = "INTERSEX"
	GenderFilterEnumNonBinary         GenderFilterEnum = "NON_BINARY"
)

var AllGenderFilterEnum = []GenderFilterEnum{
	GenderFilterEnumUnknown,
	GenderFilterEnumMale,
	GenderFilterEnumFemale,
	GenderFilterEnumTransgenderMale,
	GenderFilterEnumTransgenderFemale,
	GenderFilterEnumIntersex,
	GenderFilterEnumNonBinary,
}

func (e GenderFilterEnum) IsValid() bool {
	switch e {
	case GenderFilterEnumUnknown, GenderFilterEnumMale, GenderFilterEnumFemale, GenderFilterEnumTransgenderMale, GenderFilterEnumTransgenderFemale, GenderFilterEnumIntersex, GenderFilterEnumNonBinary:
		return true
	}
	return false
}

func (e GenderFilterEnum) String() string {
	return string(e)
}

func (e *GenderFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderFilterEnum", str)
	}
	return nil
}

func (e GenderFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HairColorEnum string

const (
	HairColorEnumBlonde   HairColorEnum = "BLONDE"
	HairColorEnumBrunette HairColorEnum = "BRUNETTE"
	HairColorEnumBlack    HairColorEnum = "BLACK"
	HairColorEnumRed      HairColorEnum = "RED"
	HairColorEnumAuburn   HairColorEnum = "AUBURN"
	HairColorEnumGrey     HairColorEnum = "GREY"
	HairColorEnumBald     HairColorEnum = "BALD"
	HairColorEnumVarious  HairColorEnum = "VARIOUS"
	HairColorEnumOther    HairColorEnum = "OTHER"
)

var AllHairColorEnum = []HairColorEnum{
	HairColorEnumBlonde,
	HairColorEnumBrunette,
	HairColorEnumBlack,
	HairColorEnumRed,
	HairColorEnumAuburn,
	HairColorEnumGrey,
	HairColorEnumBald,
	HairColorEnumVarious,
	HairColorEnumOther,
}

func (e HairColorEnum) IsValid() bool {
	switch e {
	case HairColorEnumBlonde, HairColorEnumBrunette, HairColorEnumBlack, HairColorEnumRed, HairColorEnumAuburn, HairColorEnumGrey, HairColorEnumBald, HairColorEnumVarious, HairColorEnumOther:
		return true
	}
	return false
}

func (e HairColorEnum) String() string {
	return string(e)
}

func (e *HairColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HairColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HairColorEnum", str)
	}
	return nil
}

func (e HairColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationEnum string

const (
	OperationEnumCreate  OperationEnum = "CREATE"
	OperationEnumModify  OperationEnum = "MODIFY"
	OperationEnumDestroy OperationEnum = "DESTROY"
	OperationEnumMerge   OperationEnum = "MERGE"
)

var AllOperationEnum = []OperationEnum{
	OperationEnumCreate,
	OperationEnumModify,
	OperationEnumDestroy,
	OperationEnumMerge,
}

func (e OperationEnum) IsValid() bool {
	switch e {
	case OperationEnumCreate, OperationEnumModify, OperationEnumDestroy, OperationEnumMerge:
		return true
	}
	return false
}

func (e OperationEnum) String() string {
	return string(e)
}

func (e *OperationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationEnum", str)
	}
	return nil
}

func (e OperationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PerformerSortEnum string

const (
	PerformerSortEnumName            PerformerSortEnum = "NAME"
	PerformerSortEnumBirthdate       PerformerSortEnum = "BIRTHDATE"
	PerformerSortEnumSceneCount      PerformerSortEnum = "SCENE_COUNT"
	PerformerSortEnumCareerStartYear PerformerSortEnum = "CAREER_START_YEAR"
	PerformerSortEnumDebut           PerformerSortEnum = "DEBUT"
	PerformerSortEnumLastScene       PerformerSortEnum = "LAST_SCENE"
	PerformerSortEnumCreatedAt       PerformerSortEnum = "CREATED_AT"
	PerformerSortEnumUpdatedAt       PerformerSortEnum = "UPDATED_AT"
)

var AllPerformerSortEnum = []PerformerSortEnum{
	PerformerSortEnumName,
	PerformerSortEnumBirthdate,
	PerformerSortEnumSceneCount,
	PerformerSortEnumCareerStartYear,
	PerformerSortEnumDebut,
	PerformerSortEnumLastScene,
	PerformerSortEnumCreatedAt,
	PerformerSortEnumUpdatedAt,
}

func (e PerformerSortEnum) IsValid() bool {
	switch e {
	case PerformerSortEnumName, PerformerSortEnumBirthdate, PerformerSortEnumSceneCount, PerformerSortEnumCareerStartYear, PerformerSortEnumDebut, PerformerSortEnumLastScene, PerformerSortEnumCreatedAt, PerformerSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e PerformerSortEnum) String() string {
	return string(e)
}

func (e *PerformerSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PerformerSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PerformerSortEnum", str)
	}
	return nil
}

func (e PerformerSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleEnum string

const (
	RoleEnumRead   RoleEnum = "READ"
	RoleEnumVote   RoleEnum = "VOTE"
	RoleEnumEdit   RoleEnum = "EDIT"
	RoleEnumModify RoleEnum = "MODIFY"
	RoleEnumAdmin  RoleEnum = "ADMIN"
	// May generate invites without tokens
	RoleEnumInvite RoleEnum = "INVITE"
	// May grant and rescind invite tokens and resind invite keys
	RoleEnumManageInvites RoleEnum = "MANAGE_INVITES"
	RoleEnumBot           RoleEnum = "BOT"
)

var AllRoleEnum = []RoleEnum{
	RoleEnumRead,
	RoleEnumVote,
	RoleEnumEdit,
	RoleEnumModify,
	RoleEnumAdmin,
	RoleEnumInvite,
	RoleEnumManageInvites,
	RoleEnumBot,
}

func (e RoleEnum) IsValid() bool {
	switch e {
	case RoleEnumRead, RoleEnumVote, RoleEnumEdit, RoleEnumModify, RoleEnumAdmin, RoleEnumInvite, RoleEnumManageInvites, RoleEnumBot:
		return true
	}
	return false
}

func (e RoleEnum) String() string {
	return string(e)
}

func (e *RoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleEnum", str)
	}
	return nil
}

func (e RoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SceneSortEnum string

const (
	SceneSortEnumTitle     SceneSortEnum = "TITLE"
	SceneSortEnumDate      SceneSortEnum = "DATE"
	SceneSortEnumTrending  SceneSortEnum = "TRENDING"
	SceneSortEnumCreatedAt SceneSortEnum = "CREATED_AT"
	SceneSortEnumUpdatedAt SceneSortEnum = "UPDATED_AT"
)

var AllSceneSortEnum = []SceneSortEnum{
	SceneSortEnumTitle,
	SceneSortEnumDate,
	SceneSortEnumTrending,
	SceneSortEnumCreatedAt,
	SceneSortEnumUpdatedAt,
}

func (e SceneSortEnum) IsValid() bool {
	switch e {
	case SceneSortEnumTitle, SceneSortEnumDate, SceneSortEnumTrending, SceneSortEnumCreatedAt, SceneSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e SceneSortEnum) String() string {
	return string(e)
}

func (e *SceneSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SceneSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SceneSortEnum", str)
	}
	return nil
}

func (e SceneSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StudioSortEnum string

const (
	StudioSortEnumName      StudioSortEnum = "NAME"
	StudioSortEnumCreatedAt StudioSortEnum = "CREATED_AT"
	StudioSortEnumUpdatedAt StudioSortEnum = "UPDATED_AT"
)

var AllStudioSortEnum = []StudioSortEnum{
	StudioSortEnumName,
	StudioSortEnumCreatedAt,
	StudioSortEnumUpdatedAt,
}

func (e StudioSortEnum) IsValid() bool {
	switch e {
	case StudioSortEnumName, StudioSortEnumCreatedAt, StudioSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e StudioSortEnum) String() string {
	return string(e)
}

func (e *StudioSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StudioSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StudioSortEnum", str)
	}
	return nil
}

func (e StudioSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagGroupEnum string

const (
	TagGroupEnumPeople TagGroupEnum = "PEOPLE"
	TagGroupEnumScene  TagGroupEnum = "SCENE"
	TagGroupEnumAction TagGroupEnum = "ACTION"
)

var AllTagGroupEnum = []TagGroupEnum{
	TagGroupEnumPeople,
	TagGroupEnumScene,
	TagGroupEnumAction,
}

func (e TagGroupEnum) IsValid() bool {
	switch e {
	case TagGroupEnumPeople, TagGroupEnumScene, TagGroupEnumAction:
		return true
	}
	return false
}

func (e TagGroupEnum) String() string {
	return string(e)
}

func (e *TagGroupEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagGroupEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagGroupEnum", str)
	}
	return nil
}

func (e TagGroupEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagSortEnum string

const (
	TagSortEnumName      TagSortEnum = "NAME"
	TagSortEnumCreatedAt TagSortEnum = "CREATED_AT"
	TagSortEnumUpdatedAt TagSortEnum = "UPDATED_AT"
)

var AllTagSortEnum = []TagSortEnum{
	TagSortEnumName,
	TagSortEnumCreatedAt,
	TagSortEnumUpdatedAt,
}

func (e TagSortEnum) IsValid() bool {
	switch e {
	case TagSortEnumName, TagSortEnumCreatedAt, TagSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e TagSortEnum) String() string {
	return string(e)
}

func (e *TagSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagSortEnum", str)
	}
	return nil
}

func (e TagSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetTypeEnum string

const (
	TargetTypeEnumScene     TargetTypeEnum = "SCENE"
	TargetTypeEnumStudio    TargetTypeEnum = "STUDIO"
	TargetTypeEnumPerformer TargetTypeEnum = "PERFORMER"
	TargetTypeEnumTag       TargetTypeEnum = "TAG"
)

var AllTargetTypeEnum = []TargetTypeEnum{
	TargetTypeEnumScene,
	TargetTypeEnumStudio,
	TargetTypeEnumPerformer,
	TargetTypeEnumTag,
}

func (e TargetTypeEnum) IsValid() bool {
	switch e {
	case TargetTypeEnumScene, TargetTypeEnumStudio, TargetTypeEnumPerformer, TargetTypeEnumTag:
		return true
	}
	return false
}

func (e TargetTypeEnum) String() string {
	return string(e)
}

func (e *TargetTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetTypeEnum", str)
	}
	return nil
}

func (e TargetTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserVotedFilterEnum string

const (
	UserVotedFilterEnumAbstain  UserVotedFilterEnum = "ABSTAIN"
	UserVotedFilterEnumAccept   UserVotedFilterEnum = "ACCEPT"
	UserVotedFilterEnumReject   UserVotedFilterEnum = "REJECT"
	UserVotedFilterEnumNotVoted UserVotedFilterEnum = "NOT_VOTED"
)

var AllUserVotedFilterEnum = []UserVotedFilterEnum{
	UserVotedFilterEnumAbstain,
	UserVotedFilterEnumAccept,
	UserVotedFilterEnumReject,
	UserVotedFilterEnumNotVoted,
}

func (e UserVotedFilterEnum) IsValid() bool {
	switch e {
	case UserVotedFilterEnumAbstain, UserVotedFilterEnumAccept, UserVotedFilterEnumReject, UserVotedFilterEnumNotVoted:
		return true
	}
	return false
}

func (e UserVotedFilterEnum) String() string {
	return string(e)
}

func (e *UserVotedFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserVotedFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserVotedFilterEnum", str)
	}
	return nil
}

func (e UserVotedFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValidSiteTypeEnum string

const (
	ValidSiteTypeEnumPerformer ValidSiteTypeEnum = "PERFORMER"
	ValidSiteTypeEnumScene     ValidSiteTypeEnum = "SCENE"
	ValidSiteTypeEnumStudio    ValidSiteTypeEnum = "STUDIO"
)

var AllValidSiteTypeEnum = []ValidSiteTypeEnum{
	ValidSiteTypeEnumPerformer,
	ValidSiteTypeEnumScene,
	ValidSiteTypeEnumStudio,
}

func (e ValidSiteTypeEnum) IsValid() bool {
	switch e {
	case ValidSiteTypeEnumPerformer, ValidSiteTypeEnumScene, ValidSiteTypeEnumStudio:
		return true
	}
	return false
}

func (e ValidSiteTypeEnum) String() string {
	return string(e)
}

func (e *ValidSiteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidSiteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidSiteTypeEnum", str)
	}
	return nil
}

func (e ValidSiteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteStatusEnum string

const (
	VoteStatusEnumAccepted          VoteStatusEnum = "ACCEPTED"
	VoteStatusEnumRejected          VoteStatusEnum = "REJECTED"
	VoteStatusEnumPending           VoteStatusEnum = "PENDING"
	VoteStatusEnumImmediateAccepted VoteStatusEnum = "IMMEDIATE_ACCEPTED"
	VoteStatusEnumImmediateRejected VoteStatusEnum = "IMMEDIATE_REJECTED"
	VoteStatusEnumFailed            VoteStatusEnum = "FAILED"
	VoteStatusEnumCanceled          VoteStatusEnum = "CANCELED"
)

var AllVoteStatusEnum = []VoteStatusEnum{
	VoteStatusEnumAccepted,
	VoteStatusEnumRejected,
	VoteStatusEnumPending,
	VoteStatusEnumImmediateAccepted,
	VoteStatusEnumImmediateRejected,
	VoteStatusEnumFailed,
	VoteStatusEnumCanceled,
}

func (e VoteStatusEnum) IsValid() bool {
	switch e {
	case VoteStatusEnumAccepted, VoteStatusEnumRejected, VoteStatusEnumPending, VoteStatusEnumImmediateAccepted, VoteStatusEnumImmediateRejected, VoteStatusEnumFailed, VoteStatusEnumCanceled:
		return true
	}
	return false
}

func (e VoteStatusEnum) String() string {
	return string(e)
}

func (e *VoteStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteStatusEnum", str)
	}
	return nil
}

func (e VoteStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteTypeEnum string

const (
	VoteTypeEnumAbstain VoteTypeEnum = "ABSTAIN"
	VoteTypeEnumAccept  VoteTypeEnum = "ACCEPT"
	VoteTypeEnumReject  VoteTypeEnum = "REJECT"
	// Immediately accepts the edit - bypassing the vote
	VoteTypeEnumImmediateAccept VoteTypeEnum = "IMMEDIATE_ACCEPT"
	// Immediately rejects the edit - bypassing the vote
	VoteTypeEnumImmediateReject VoteTypeEnum = "IMMEDIATE_REJECT"
)

var AllVoteTypeEnum = []VoteTypeEnum{
	VoteTypeEnumAbstain,
	VoteTypeEnumAccept,
	VoteTypeEnumReject,
	VoteTypeEnumImmediateAccept,
	VoteTypeEnumImmediateReject,
}

func (e VoteTypeEnum) IsValid() bool {
	switch e {
	case VoteTypeEnumAbstain, VoteTypeEnumAccept, VoteTypeEnumReject, VoteTypeEnumImmediateAccept, VoteTypeEnumImmediateReject:
		return true
	}
	return false
}

func (e VoteTypeEnum) String() string {
	return string(e)
}

func (e *VoteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteTypeEnum", str)
	}
	return nil
}

func (e VoteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
